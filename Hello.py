# # # # # # # # # # # # # #!/usr/bin/env python3
# # # # # # # # # # # # # # -*- coding: utf-8 -*-
# # # # # # # # # # # # #
# # # # # # # # # # # # # # print('hello world')
# # # # # # # # # # # # #
# # # # # # # # # # # # # # name = input('please enter your name: ')
# # # # # # # # # # # # # # print('hello,', name)
# # # # # # # # # # # # #
# # # # # # # # # # # # # # print(type(name))
# # # # # # # # # # # # #
# # # # # # # # # # # # # # age = 4
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # if age >= 18:
# # # # # # # # # # # # # #     print ("123")
# # # # # # # # # # # # # # else:
# # # # # # # # # # # # # #     print ("456")
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # a = 123 #a 是整数
# # # # # # # # # # # # # # print(a)
# # # # # # # # # # # # # # b = 'ABC' #b为字符串
# # # # # # # # # # # # # # print(b)
# # # # # # # # # # # # #
# # # # # # # # # # # # # # 导入实除法模块后的结果即为浮点数
# # # # # # # # # # # # # # from __future__ import division
# # # # # # # # # # # # # # a = 10 / 3
# # # # # # # # # # # # # # print(a)
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # # def power(x, n):
# # # # # # # # # # # # # #     s = 1
# # # # # # # # # # # # # #     while n > 0:
# # # # # # # # # # # # # #         n = n - 1
# # # # # # # # # # # # # #         s = s * x
# # # # # # # # # # # # # #     return s
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # print (power(3, 3))
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # # def power(x, n=2):
# # # # # # # # # # # # # #     s = 1
# # # # # # # # # # # # # #     while n > 0:
# # # # # # # # # # # # # #         n = n - 1
# # # # # # # # # # # # # #         s = s * x
# # # # # # # # # # # # # #     return s
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # print ('power2 = %d' % power(5))
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # 多个占位符
# # # # # # # # # # # # # # s = "I am %s,age %d" % ('alex', 18)
# # # # # # # # # # # # # # print(s)
# # # # # # # # # # # # #
# # # # # # # # # # # # # # 不添加默认的参数
# # # # # # # # # # # # # # def enroll(name, gender):
# # # # # # # # # # # # # #     print('name: %s' % name)
# # # # # # # # # # # # # #     print('gender: %s' % gender)
# # # # # # # # # # # # # #     return
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # enroll('jack', 'boy')
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # # 添加默认的参数
# # # # # # # # # # # # # # def enroll(name, gender, age=6, city='Beijing'):
# # # # # # # # # # # # # #     print('name: %s' % name)
# # # # # # # # # # # # # #     print('gender: %s' % gender)
# # # # # # # # # # # # # #     print('age: %d' % age)
# # # # # # # # # # # # # #     print('city: %s' % city)
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # # enroll('Lucy', 'girl')
# # # # # # # # # # # # # # enroll('Bod', 'Boy', 17)
# # # # # # # # # # # # # # enroll('Adam', 'Boy', 20, city='Tianjin')
# # # # # # # # # # # # # # enroll('jack', 'boy', 20, 'Tianjin')
# # # # # # # # # # # # #
# # # # # # # # # # # # # # 添加默认参数的坑
# # # # # # # # # # # # # # def add_end(L=[]):
# # # # # # # # # # # # # #     L.append('end')
# # # # # # # # # # # # # #     return L
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # # 多次调用默认函数
# # # # # # # # # # # # # # print(add_end())
# # # # # # # # # # # # # # print(add_end())
# # # # # # # # # # # # # # 此处打印，本应为一个'end'，结果打印了三个
# # # # # # # # # # # # # # 定义默认参数：默认参数必须指向不变对象
# # # # # # # # # # # # # # print(add_end())
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # # 默认参数的正确写法
# # # # # # # # # # # # # # def add_end(L=None):
# # # # # # # # # # # # # #     if L is None:
# # # # # # # # # # # # # #         L = []
# # # # # # # # # # # # # #     L.append('END')
# # # # # # # # # # # # # #     return L
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # print(add_end())
# # # # # # # # # # # # # # print(add_end())
# # # # # # # # # # # # # # print(add_end())
# # # # # # # # # # # # #
# # # # # # # # # # # # # # 可变参数
# # # # # # # # # # # # # # def calc(numbers):
# # # # # # # # # # # # # #     sum = 0
# # # # # # # # # # # # # #     for n in numbers:
# # # # # # # # # # # # # #         sum = sum + n * n
# # # # # # # # # # # # # #     return sum
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # print(calc([1, 2, 3]))
# # # # # # # # # # # # # # # print(calc([1, 3, 5, 7]))
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # print(calc([]))
# # # # # # # # # # # # # # # 此处传入的参数应为空list或tuple，传入为空会报错
# # # # # # # # # # # # # # # print(calc())
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # 1.重写此方法，在number前加上*号，将接受的参数变为可变参数
# # # # # # # # # # # # # # # 2.加上*号，接收到的number依然是list或者tuple，函数代码完全不变
# # # # # # # # # # # # # # def calc(*numbers):
# # # # # # # # # # # # # #     sum = 0
# # # # # # # # # # # # # #     for n in numbers:
# # # # # # # # # # # # # #         sum = sum + n * n
# # # # # # # # # # # # # #     return sum
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # print(calc(1, 2, 3))
# # # # # # # # # # # # # # # print(calc())
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # 假如传入的为list或者tuple，加上*即可
# # # # # # # # # # # # # # # *nums表示把nums这个list的所有元素作为可变参数传进去
# # # # # # # # # # # # # # nums = [1, 2, 3]
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # print(calc(*nums))
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # def person(name, age, **kw):
# # # # # # # # # # # # # #     print('name:', name, 'age:', age, \
# # # # # # # # # # # # # #           'other:', kw)
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # person('jack', 30)
# # # # # # # # # # # # # # # person('tom', 28, city='Beijing')
# # # # # # # # # # # # # # # person('bob', 12, gender='boy', city='Tianjin')
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # extra = {'city': 'Beijing', 'job': 'Engineer'}
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # 注意kw获得的dict是extra的一份拷贝，对kw的改动\
# # # # # # # # # # # # # # # 不会影响到函数外的extra，作用是可以添加额外的参数
# # # # # # # # # # # # # # # person('mike', 23, **extra)
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # 关键字参数
# # # # # # # # # # # # # # # def person(name, age, **kw):
# # # # # # # # # # # # # # #     if 'city' in kw:
# # # # # # # # # # # # # # #         # 有city参数
# # # # # # # # # # # # # # #         pass
# # # # # # # # # # # # # # #     if 'job' in kw:
# # # # # # # # # # # # # # #         # 有job参数
# # # # # # # # # # # # # # #         pass
# # # # # # # # # # # # # # #     print('name:%s' % name, 'age:%d' % age, 'other:', kw)
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # person('jack', 21, city='Beijing', addr='Chaoyang',\
# # # # # # # # # # # # # # #        zipcode=12345)
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # def person(name, age, *, city, job):
# # # # # # # # # # # # # #     print(name, age, city, job)
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # person('jack', 24, city='Beijing', job='Engineer')
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # def person(name, age, *args, city, job):
# # # # # # # # # # # # # #     print(name, age, args, city, job)
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # 此处调用时，需要参数名（city， job），否则就会报错
# # # # # # # # # # # # # # # person('jack', 25, city='Beijing', job='teacher')
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # 添加默认的关键字参数
# # # # # # # # # # # # # # def person(name, age, *, city='Beijing', job):
# # # # # # # # # # # # # #     print(name, age, city, job)
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # person('mike', 32, job='student')
# # # # # # # # # # # # # # # 也可以在外部更改默认的关键字参数，可以传入空值
# # # # # # # # # # # # # # # person('mike', 21, city='Tianjin', job='student')
# # # # # # # # # # # # # # # person('mike', 21, city='', job='student')
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # 参数的组合：
# # # # # # # # # # # # # # # 定义参数的顺序为：必选参数、默认参数、可变参数、
# # # # # # # # # # # # # # # 命名关键字参数、关键字参数
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # 定义一个参数，包含上述若干种参数
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # def f1(a, b, c=0, *args, **kw):
# # # # # # # # # # # # # #     print('a =', a, 'b =', b, 'c =', c, 'args =', args, \
# # # # # # # # # # # # # #           'kw =', kw)
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # f1(1, 2)
# # # # # # # # # # # # # # # f1(1, 2, c=3, city='Beijing')
# # # # # # # # # # # # # # # f1(1, 2, 3, '1', '2')
# # # # # # # # # # # # # # # f1(1, 2, 0, 1, 2, 3, city='Beijing')
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # def f2(a, b, c=0, *, d, **kw):
# # # # # # # # # # # # # #     print('a2 =', a, 'b =', b, 'c =', c, 'd =', d,\
# # # # # # # # # # # # # #           'kw =', kw)
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # f2(3, 4, 5, d=6, student=23)
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # 通过tuple或者dict也可以调用上述函数
# # # # # # # # # # # # # # args = (1, 2, 3, 4)
# # # # # # # # # # # # # # kw = {'q': 00, 'x': 'y'}
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # f1(*args, **kw)
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # args = (1, 2, 3)
# # # # # # # # # # # # # # kw = {'d': 00, 'x': 'y'}
# # # # # # # # # # # # # # # f2(*args, **kw)
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # def product(x, y):
# # # # # # # # # # # # # #     return x * y
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # def product(a, *args):
# # # # # # # # # # # # # #     sum = a
# # # # # # # # # # # # # #     for n in args:
# # # # # # # # # # # # # #         sum = sum*n
# # # # # # # # # # # # # #     return sum
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # print('product(5) =', product(5))
# # # # # # # # # # # # # # print('product(5, 6) =', product(5, 6))
# # # # # # # # # # # # # # print('product(5, 6, 7) =', product(5, 6, 7))
# # # # # # # # # # # # # # print('product(5, 6, 7, 9) =', product(5, 6, 7, 9))
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # if product(5) != 5:
# # # # # # # # # # # # # #     print('测试失败!')
# # # # # # # # # # # # # # elif product(5, 6) != 30:
# # # # # # # # # # # # # #     print('测试失败!')
# # # # # # # # # # # # # # elif product(5, 6, 7) != 210:
# # # # # # # # # # # # # #     print('测试失败!')
# # # # # # # # # # # # # # elif product(5, 6, 7, 9) != 1890:
# # # # # # # # # # # # # #     print('测试失败!')
# # # # # # # # # # # # # # else:
# # # # # # # # # # # # # #     try:
# # # # # # # # # # # # # #         product()
# # # # # # # # # # # # # #         print('测试失败!')
# # # # # # # # # # # # # #     except TypeError:
# # # # # # # # # # # # # #         print('测试成功!')
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # # def fact(n):
# # # # # # # # # # # # # #     if n == 1:
# # # # # # # # # # # # # #         return 1
# # # # # # # # # # # # # #     return n * fact(n - 1)
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # print(fact(1))
# # # # # # # # # # # # # # # print(fact(5))
# # # # # # # # # # # # # # # print(fact(1000))
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # 上边的方式会造成栈的溢出
# # # # # # # # # # # # # # # 解决方法是通过尾递归优化，在函数返回是，调用本身，并且不包含表达式
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # def fact(n):
# # # # # # # # # # # # # #     return fact_iter(n, 1)
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # def fact_iter(num, product):
# # # # # # # # # # # # # #     if num == 1:
# # # # # # # # # # # # # #         return product
# # # # # # # # # # # # # #     return fact_iter(num - 1, num * product)
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # print(fact_iter(10, 1))
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # def move(n, a, b, c):
# # # # # # # # # # # # # #     if n == 1:
# # # # # # # # # # # # # #         print(a, '-->', c)
# # # # # # # # # # # # # #     else:
# # # # # # # # # # # # # #         move(n - 1, a, c, b)
# # # # # # # # # # # # # #         move(1, a, b, c)
# # # # # # # # # # # # # #         move(n - 1, b, a, c)
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # 递归赋值（话说网上真的是能人辈出）
# # # # # # # # # # # # # # # print(move(3, 'A', 'B', 'C'))
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # 切片
# # # # # # # # # # # # # # L = ['mike', 'bob', 'jack', 'lucy', 'tom']
# # # # # # # # # # # # # # # 取出前三个元素
# # # # # # # # # # # # # # print(L[0:3])
# # # # # # # # # # # # # # # 如果包含第一个元素的话，可以将0省略
# # # # # # # # # # # # # # print(L[:3])
# # # # # # # # # # # # # # # 取出第二三个元素
# # # # # # # # # # # # # # print(L[1:3])
# # # # # # # # # # # # # # # 也可倒数切片，例如-1
# # # # # # # # # # # # # # print(L[-2:])
# # # # # # # # # # # # # # print(L[-2:-1])
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # 取数练习
# # # # # # # # # # # # # # b = list(range(100))
# # # # # # # # # # # # # # print(b[:10])
# # # # # # # # # # # # # # print(b[-10:])
# # # # # # # # # # # # # # print(b[10:20])
# # # # # # # # # # # # # # # 前十个数，每隔两个取一个
# # # # # # # # # # # # # # print(b[:10:2])
# # # # # # # # # # # # # # # 所有数，每5个取一个
# # # # # # # # # # # # # # print(b[::5])
# # # # # # # # # # # # # # # 取出所有数
# # # # # # # # # # # # # # # print(b[:])
# # # # # # # # # # # # # # # 字符串也可用来切片
# # # # # # # # # # # # # # # 但是针对字符串的截取，有各种的系统方法(例如，substring)
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # str = '  hello  '
# # # # # # # # # # # # # # print(str[:1])
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # def trim(s):
# # # # # # # # # # # # # #     if s[:1] == " ":
# # # # # # # # # # # # # #         return trim(s[1:])
# # # # # # # # # # # # # #     if s[-1:] == " ":
# # # # # # # # # # # # # #         return trim(s[:-1])
# # # # # # # # # # # # # #     return s
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # if trim('hello  ') != 'hello':
# # # # # # # # # # # # # #     print('测试失败!')
# # # # # # # # # # # # # # elif trim('  hello') != 'hello':
# # # # # # # # # # # # # #     print('测试失败!')
# # # # # # # # # # # # # # elif trim('  hello  ') != 'hello':
# # # # # # # # # # # # # #     print('测试失败!')
# # # # # # # # # # # # # # elif trim('  hello  world  ') != 'hello  world':
# # # # # # # # # # # # # #     print('测试失败!')
# # # # # # # # # # # # # # elif trim('') != '':
# # # # # # # # # # # # # #     print('测试失败!')
# # # # # # # # # # # # # # elif trim('    ') != '':
# # # # # # # # # # # # # #     print('测试失败!')
# # # # # # # # # # # # # # else:
# # # # # # # # # # # # # #     print('测试成功!')
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # # d = {'a': 1, 'b': 2, 'c': 3}
# # # # # # # # # # # # # # # Python中的遍历循环，称之为迭代
# # # # # # # # # # # # # # # 迭代dict中的key
# # # # # # # # # # # # # # for key in d:
# # # # # # # # # # # # # #     print(key)
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # 迭代dict中的Value
# # # # # # # # # # # # # # for value in d.values():
# # # # # # # # # # # # # #     print(value)
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # 迭代dict中的Value和key
# # # # # # # # # # # # # # for k, v in d.items():
# # # # # # # # # # # # # #     print(k, v)
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # 字符串也可以迭代
# # # # # # # # # # # # # # for ch in 'ABC':
# # # # # # # # # # # # # #     print(ch)
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # 判断一个对象是否可迭代
# # # # # # # # # # # # # # from collections import Iterable
# # # # # # # # # # # # # # print(isinstance('abc', Iterable))
# # # # # # # # # # # # # # print(isinstance([1, 2, 3], Iterable))
# # # # # # # # # # # # # # # 整数不能迭代
# # # # # # # # # # # # # # print(isinstance(123, Iterable))
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # Python内置的enumerate函数可以把一个list变成索引-元素对
# # # # # # # # # # # # # # for i, value in enumerate(['A', 'B', 'c']):
# # # # # # # # # # # # # #     print(i, value)
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # for x, y in ([1, 1], [2, 4], [3, 9]):
# # # # # # # # # # # # # #     print(x, y)
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # 请使用迭代查找一个list中最小和最大值，并返回一个tuple
# # # # # # # # # # # # # # def findMinAndMax(L):
# # # # # # # # # # # # # #     if L == []:
# # # # # # # # # # # # # #         return (None, None)
# # # # # # # # # # # # # #     else:
# # # # # # # # # # # # # #         MIN = L[0]
# # # # # # # # # # # # # #         MAX = L[0]
# # # # # # # # # # # # # #         for X in L:
# # # # # # # # # # # # # #             if MIN >= X:
# # # # # # # # # # # # # #                 MIN = X
# # # # # # # # # # # # # #             elif MAX <= X:
# # # # # # # # # # # # # #                 MAX = X
# # # # # # # # # # # # # #         return (MIN, MAX)
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # if findMinAndMax([]) != (None, None):
# # # # # # # # # # # # # #     print('测试失败!')
# # # # # # # # # # # # # # elif findMinAndMax([7]) != (7, 7):
# # # # # # # # # # # # # #     print('测试失败!')
# # # # # # # # # # # # # # elif findMinAndMax([7, 1]) != (1, 7):
# # # # # # # # # # # # # #     print('测试失败!')
# # # # # # # # # # # # # # elif findMinAndMax([7, 1, 3, 9, 5]) != (1, 9):
# # # # # # # # # # # # # #     print('测试失败!')
# # # # # # # # # # # # # # else:
# # # # # # # # # # # # # #     print('测试成功!')
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # # print(list(range(1, 11)))
# # # # # # # # # # # # # # # 列表生成式，快速生成list
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # L = []
# # # # # # # # # # # # # # for x in range(1, 11):
# # # # # # # # # # # # # #     L.append(x * x)
# # # # # # # # # # # # # # print(L)
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # #在列表生成式中，可以使用运算式，来得到自己想要的list
# # # # # # # # # # # # # # print([x*x for x in range(1, 11)])
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # or循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方
# # # # # # # # # # # # # # print([x*x for x in range(1, 11) if x % 2 ==0])
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # 还可以使用两层循环，可以生成全排列
# # # # # # # # # # # # # # print([m + n for m in 'ABC' for n in 'XYZ'])
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # 导入os模块
# # # # # # # # # # # # # # import os
# # # # # # # # # # # # # # # os.listdir可以列出文件和目录
# # # # # # # # # # # # # # print([d for d in os.listdir('.')])
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # for循环其实可以同时使用两个甚至多个变量
# # # # # # # # # # # # # # # 比如dict的items()可以同时迭代key和value
# # # # # # # # # # # # # # d = {'x': 'A', 'y': 'B', 'z': 'C'}
# # # # # # # # # # # # # # for k, v in d.items():
# # # # # # # # # # # # # #     print(k, '=', v)
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # 列表生成式也可以使用两个变量来生成list
# # # # # # # # # # # # # # print([k + '=' + v for k, v in d.items()])
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # 把一个list中所有的字符串变成小写
# # # # # # # # # # # # # # L = ['Hello', 'World', 'IBM', 'Apple']
# # # # # # # # # # # # # # print([s.lower() for s in L])
# # # # # # # # # # # # # # # 把一个list中所有的字符串变成大写
# # # # # # # # # # # # # # print([s.upper() for s in L])
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # 使用内建的isinstance函数可以判断一个变量是不是字符串
# # # # # # # # # # # # # # x = 'abc'
# # # # # # # # # # # # # # y = 123
# # # # # # # # # # # # # # z = ''
# # # # # # # # # # # # # # print(isinstance(x, str))
# # # # # # # # # # # # # # # 也可用来判断是否是数字
# # # # # # # # # # # # # # print(isinstance(y, int))
# # # # # # # # # # # # # # # 判断是否为空
# # # # # # # # # # # # # # print(isinstance(z, str))
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # 修改列表生成式，通过添加if语句保证列表生成式能正确地执行
# # # # # # # # # # # # # # L1 = ['Hello', 'World', 18, 'Apple', None]
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # L2 = [s.lower() for s in L1 if isinstance(s, str)]
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # 测试:
# # # # # # # # # # # # # # print(L2)
# # # # # # # # # # # # # # if L2 == ['hello', 'world', 'apple']:
# # # # # # # # # # # # # #     print('测试通过!')
# # # # # # # # # # # # # # else:
# # # # # # # # # # # # # #     print('测试失败!')
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # # L = [x*x for x in range(10)]
# # # # # # # # # # # # # # # print(L)
# # # # # # # # # # # # # # g = (x*x for x in range(10))
# # # # # # # # # # # # # # # 在Python中，这种一边循环一边计算的机制，称为生成器：generator
# # # # # # # # # # # # # # # 创建L和g的区别仅在于最外层的[]和()
# # # # # # # # # # # # # # # L是一个list，而g是一个generator
# # # # # # # # # # # # # # # generator并没有创建一个完整的数组，而是在不断的调用中生成
# # # # # # # # # # # # # # # 主要的目的在于节省空间
# # # # # # # # # # # # # # # print(g)
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # #打印g中的所有元素
# # # # # # # # # # # # # # # for n in g:
# # # # # # # # # # # # # # #     print(n)
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # generator非常强大。如果推算的算法比较复杂
# # # # # # # # # # # # # # # 用类似列表生成式的for循环无法实现的时候，还可以用函数来实现
# # # # # # # # # # # # # # def fib(max):
# # # # # # # # # # # # # #     n, a, b = 0, 0, 1
# # # # # # # # # # # # # #     while n < max:
# # # # # # # # # # # # # #         print(b)
# # # # # # # # # # # # # #         a, b = b, a + b
# # # # # # # # # # # # # #         n = n + 1
# # # # # # # # # # # # # #     return 'done'
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # fib(6)
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # 修改上边函数为generator
# # # # # # # # # # # # # # # 要把fib函数变成generator，只需要把print(b)改为yield b就可以了
# # # # # # # # # # # # # # def fib(max):
# # # # # # # # # # # # # #     n, a, b = 0, 0, 1
# # # # # # # # # # # # # #     while n < max:
# # # # # # # # # # # # # #         yield b
# # # # # # # # # # # # # #         a, b = b, a + b
# # # # # # # # # # # # # #         n = n + 1
# # # # # # # # # # # # # #     return 'done'
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # f = fib(6)
# # # # # # # # # # # # # # print(f)
# # # # # # # # # # # # # # # 这是定义generator的另一种方法。如果一个函数定义中包含yield关键字
# # # # # # # # # # # # # # # 那么这个函数就不再是一个普通函数，而是一个generator
# # # # # # # # # # # # # # # for n in fib(6):
# # # # # # # # # # # # # # #     print(n)
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # 捕获错误的发生
# # # # # # # # # # # # # # # g = fib(6)
# # # # # # # # # # # # # # # while True:
# # # # # # # # # # # # # # #     try:
# # # # # # # # # # # # # # #         x = next(g)
# # # # # # # # # # # # # # #         print('g:', x)
# # # # # # # # # # # # # # #     except StopIteration as e:
# # # # # # # # # # # # # # #         print('Generator return value:', e.value)
# # # # # # # # # # # # # # #         break
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # def triangles():
# # # # # # # # # # # # # #     tr = [1]
# # # # # # # # # # # # # #     while True:
# # # # # # # # # # # # # #         yield tr
# # # # # # # # # # # # # #         ntr = tr[:]
# # # # # # # # # # # # # #         for i in range(len(tr)):
# # # # # # # # # # # # # #             if i == 0:
# # # # # # # # # # # # # #                 ntr[i] = 1
# # # # # # # # # # # # # #             else:
# # # # # # # # # # # # # #                 ntr[i] = tr[i] + tr[i-1]
# # # # # # # # # # # # # #         ntr.append(1)
# # # # # # # # # # # # # #         tr = ntr[:]
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # n = 0
# # # # # # # # # # # # # # results = []
# # # # # # # # # # # # # # for t in triangles():
# # # # # # # # # # # # # #     print(t)
# # # # # # # # # # # # # #     results.append(t)
# # # # # # # # # # # # # #     n = n + 1
# # # # # # # # # # # # # #     if n == 10:
# # # # # # # # # # # # # #         break
# # # # # # # # # # # # # # if results == [
# # # # # # # # # # # # # #     [1],
# # # # # # # # # # # # # #     [1, 1],
# # # # # # # # # # # # # #     [1, 2, 1],
# # # # # # # # # # # # # #     [1, 3, 3, 1],
# # # # # # # # # # # # # #     [1, 4, 6, 4, 1],
# # # # # # # # # # # # # #     [1, 5, 10, 10, 5, 1],
# # # # # # # # # # # # # #     [1, 6, 15, 20, 15, 6, 1],
# # # # # # # # # # # # # #     [1, 7, 21, 35, 35, 21, 7, 1],
# # # # # # # # # # # # # #     [1, 8, 28, 56, 70, 56, 28, 8, 1],
# # # # # # # # # # # # # #     [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]
# # # # # # # # # # # # # # ]:
# # # # # # # # # # # # # #     print('测试通过!')
# # # # # # # # # # # # # # else:
# # # # # # # # # # # # # #     print('测试失败!')
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # # from collections import Iterable
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # 可以直接作用于for循环的对象统称为迭代对象：Iterable
# # # # # # # # # # # # # # # 使用isinstance()判断一个对象是否为Iterable
# # # # # # # # # # # # # # # print(isinstance([], Iterable))
# # # # # # # # # # # # # # # print(isinstance(123, Iterable))
# # # # # # # # # # # # # # # print(isinstance((x for x in range(10)), Iterable))
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # 可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator
# # # # # # # # # # # # # # # 可以使用isinstance()判断一个对象是否是Iterator对象
# # # # # # # # # # # # # # from collections import Iterator
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # print(isinstance('abc', Iterator))
# # # # # # # # # # # # # # # print(isinstance((x for x in range(10)), Iterator))
# # # # # # # # # # # # # # # 把list、dict、str等Iterable变成Iterator可以使用iter()函数
# # # # # # # # # # # # # # # print(isinstance(iter([]), Iterator))
# # # # # # # # # # # # # # # print(isinstance(iter('abc'), Iterator))
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # 函数名也是变量，可以通过赋值把一个整数赋值给函数名
# # # # # # # # # # # # # # # 既然变量可以指向函数，函数的参数能接收变量
# # # # # # # # # # # # # # # 那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数
# # # # # # # # # # # # # # # 列举一个简单的高阶函数
# # # # # # # # # # # # # # def add(x, y, f):
# # # # # # # # # # # # # #     return f(x) + f(y)
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # print(add(-5, 6, abs))
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # map()函数接收两个参数，一个是函数，一个是Iterable
# # # # # # # # # # # # # # # 一个函数f(x)=x2(x的平方)
# # # # # # # # # # # # # # # 把这个函数作用在一个list [1, 2, 3, 4, 5, 6, 7, 8, 9]上
# # # # # # # # # # # # # # def f(x):
# # # # # # # # # # # # # #     return x * x
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
# # # # # # # # # # # # # # # print(list(r))
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # reduce把一个函数作用在一个序列[x1, x2, x3, ...]上
# # # # # # # # # # # # # # # 这个函数必须接收两个参数
# # # # # # # # # # # # # # # reduce把结果继续和序列的下一个元素做累积计算
# # # # # # # # # # # # # # # 等价于:reduce(f,[x1, x2, x3, x4]) = f(f(f(x1, x2), x3),x4)
# # # # # # # # # # # # # # from functools import reduce
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # def add(x, y):
# # # # # # # # # # # # # #     return x + y
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # print(reduce(add, [1, 3, 5, 7, 9]))
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # def fn(x, y):
# # # # # # # # # # # # # #     return x * 10 + y
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # print(reduce(fn, [1, 3, 5, 7, 9]))
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # def charm2num(s):
# # # # # # # # # # # # # #     digits = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, \
# # # # # # # # # # # # # #               '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}
# # # # # # # # # # # # # #     return digits[s]
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # print(reduce(fn, map(charm2num, '13579')))
# # # # # # # # # # # # # # #
# # # # # # # # # # # # # # # print(charm2num('5'))
# # # # # # # # # # # # # # # print(list(map(charm2num, '12345')))
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # DIGITS = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, \
# # # # # # # # # # # # # #           '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # def str2int(s):
# # # # # # # # # # # # # #     def fn(x, y):
# # # # # # # # # # # # # #         return x * 10 + y
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #     def charm2num(s):
# # # # # # # # # # # # # #         return DIGITS[s]
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #     return reduce(fn, map(charm2num, s))
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # print(str2int('123456'))
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # 继续简化
# # # # # # # # # # # # # # def charm2num(s):
# # # # # # # # # # # # # #     return DIGITS[s]
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # def str2int(s):
# # # # # # # # # # # # # #     return reduce(lambda x, y: x * 10 + y, map(charm2num, s))
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # # print(str2int('1234'))
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # def normalize(name):
# # # # # # # # # # # # # #     str1 = name[:1].upper() + name[1:].lower()
# # # # # # # # # # # # # #     return str1
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # L1 = ['adam', 'LISA', 'barT']
# # # # # # # # # # # # # # L2 = list(map(normalize, L1))
# # # # # # # # # # # # # # print(L2)
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # def prod(L):
# # # # # # # # # # # # # #     def sum1(x, y):
# # # # # # # # # # # # # #         return x * y
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #     return reduce(sum1, L)
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # print('3 * 5 * 7 * 9 =', prod([3, 5, 7, 9]))
# # # # # # # # # # # # # # if prod([3, 5, 7, 9]) == 945:
# # # # # # # # # # # # # #     print('测试成功!')
# # # # # # # # # # # # # # else:
# # # # # # # # # # # # # #     print('测试失败!')
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # def str2float(s):
# # # # # # # # # # # # # #     return reduce(lambda x, y: x * 10 + y, \
# # # # # # # # # # # # # #                   map(int, s.split('.')[0])) + \
# # # # # # # # # # # # # #            reduce(lambda x, y: x / 10 + y, \
# # # # # # # # # # # # # #                   map(int, s.split('.')[-1][::-1])) / 10
# # # # # # # # # # # # # #
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # print('str2float(\'123.456\') =', str2float('123.456'))
# # # # # # # # # # # # # # if abs(str2float('123.456') - 123.456) < 0.00001:
# # # # # # # # # # # # # #     print('测试成功!')
# # # # # # # # # # # # # # else:
# # # # # # # # # # # # # #     print('测试失败!')
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # def is_odd(n):
# # # # # # # # # # # # #     return n % 2 == 1
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # # filter()函数用于过滤序列
# # # # # # # # # # # # # # filter()函数也是用来接受两个参数，和map()函数一样是作用于
# # # # # # # # # # # # # # 序列中的每个元素，但是根据返回的True和false来确定是否保留元素
# # # # # # # # # # # # # print(list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15])))
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # # strip() 方法用于移除字符串头尾指定的字符（默认为空格)
# # # # # # # # # # # # # def not_empty(s):
# # # # # # # # # # # # #     return s and s.strip()
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # print(list(filter(not_empty, ['A', '', 'B', None, 'C', '  '])))
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # # 用filter求素数
# # # # # # # # # # # # # def _odd_iter():
# # # # # # # # # # # # #     n = 1
# # # # # # # # # # # # #     while True:
# # # # # # # # # # # # #         n = n + 2
# # # # # # # # # # # # #         yield n
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # # 筛选序列
# # # # # # # # # # # # # def _not_divisiable(n):
# # # # # # # # # # # # #     return lambda x: x % n > 0
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # def primes():
# # # # # # # # # # # # #     yield 2
# # # # # # # # # # # # #     it = _odd_iter()  # 初始序列
# # # # # # # # # # # # #     while True:
# # # # # # # # # # # # #         n = next(it)  # 返回序列的第一个数
# # # # # # # # # # # # #         yield n
# # # # # # # # # # # # #         it = filter(_not_divisiable(n), it)
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # for n in primes():
# # # # # # # # # # # # #     if n < 1000:
# # # # # # # # # # # # #         pass
# # # # # # # # # # # # #         # print(n)
# # # # # # # # # # # # #     else:
# # # # # # # # # # # # #         break
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # def is_palindrome(n):
# # # # # # # # # # # # #     return str(n) == str(n)[::-1]
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # output = filter(is_palindrome, range(1, 1000))
# # # # # # # # # # # # # print('1~1000:', list(output))
# # # # # # # # # # # # # if list(filter(is_palindrome, range(1, 200))) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191]:
# # # # # # # # # # # # #     print('测试成功!')
# # # # # # # # # # # # # else:
# # # # # # # # # # # # #     print('测试失败!')
# # # # # # # # # # # #
# # # # # # # # # # # #
# # # # # # # # # # # # print(sorted([36, 5, -12, 9, -21]))
# # # # # # # # # # # # # 接受一个key函数来实现自定义的排序，例如，按数值的绝对值大小排序
# # # # # # # # # # # # print(sorted([36, 5, -12, 9, -21], key=abs))
# # # # # # # # # # # # # 字符串的排序，根据ASCII码来排序的
# # # # # # # # # # # # print(sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower))
# # # # # # # # # # # # # 将上述函数进行反向排序
# # # # # # # # # # # # print(sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True))
# # # # # # # # # # # #
# # # # # # # # # # # # # 对下列的学生分数，按姓名排序
# # # # # # # # # # # # L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]
# # # # # # # # # # # #
# # # # # # # # # # # #
# # # # # # # # # # # # def by_name(t):
# # # # # # # # # # # #     # print('t = %s' % t[0])
# # # # # # # # # # # #     return t[0]
# # # # # # # # # # # #
# # # # # # # # # # # #
# # # # # # # # # # # # L2 = sorted(L, key=by_name)
# # # # # # # # # # # # print(L2)
# # # # # # # # # # # #
# # # # # # # # # # # #
# # # # # # # # # # # # # 按照成绩排序
# # # # # # # # # # # # def by_score(t):
# # # # # # # # # # # #     return t[1]
# # # # # # # # # # # #
# # # # # # # # # # # #
# # # # # # # # # # # # L2 = sorted(L, key=by_score, reverse=True)
# # # # # # # # # # # # print(L2)
# # # # # # # # # # # #
# # # # # # # # # # # #
# # # # # # # # # # # #
# # # # # # # # # # #
# # # # # # # # # # #
# # # # # # # # # # # def calc_sum(*args):
# # # # # # # # # # #     ax = 0
# # # # # # # # # # #     for n in args:
# # # # # # # # # # #         ax = ax + n
# # # # # # # # # # #     return ax
# # # # # # # # # # #
# # # # # # # # # # #
# # # # # # # # # # # # 延时计算求和
# # # # # # # # # # # def lazy_sum(*args):
# # # # # # # # # # #     def sum():
# # # # # # # # # # #         ax = 0
# # # # # # # # # # #         for n in args:
# # # # # # # # # # #             ax = ax + n
# # # # # # # # # # #         return ax
# # # # # # # # # # #     return sum
# # # # # # # # # # #
# # # # # # # # # # #
# # # # # # # # # # # # 调用lazy_sum()，返回的不是求和结果，而是求和函数：
# # # # # # # # # # # f = lazy_sum(1,3,5,7,9)
# # # # # # # # # # # print(f)
# # # # # # # # # # #
# # # # # # # # # # # # 调用函数f时，才真正计算求和结果
# # # # # # # # # # # print(f())
# # # # # # # # # # #
# # # # # # # # # # # # 当我们调用函数lazy_sum()时，每次都会返回一个新的函数，即使传入的参数是一致的
# # # # # # # # # # # f1 = lazy_sum(1, 3, 5, 7, 9)
# # # # # # # # # # # f2 = lazy_sum(1, 3, 5, 7, 9)
# # # # # # # # # # # print(f1 == f2)
# # # # # # # # # # #
# # # # # # # # # # # # 闭包
# # # # # # # # # # # def count():
# # # # # # # # # # #     fs = []
# # # # # # # # # # #     for i in range(1, 4):
# # # # # # # # # # #         def f():
# # # # # # # # # # #             return i*i
# # # # # # # # # # #         fs.append(f)
# # # # # # # # # # #     return fs
# # # # # # # # # # #
# # # # # # # # # # #
# # # # # # # # # # # f1, f2, f3 = count()
# # # # # # # # # # #
# # # # # # # # # # # # 此处的打印结果都为9，与想要的结果不符
# # # # # # # # # # # # 原因在于函数引用的i，并非立刻执行的。三个函数都返回时，引用的i变为3，因此最终结果为9
# # # # # # # # # # # # 所以返回闭包时：返回函数不要引用任何循环变量，或者后续会发生变化的变量
# # # # # # # # # # # print(f1())
# # # # # # # # # # # print(f2())
# # # # # # # # # # # print(f3())
# # # # # # # # # # #
# # # # # # # # # # #
# # # # # # # # # # # # 此函数的正确写法应为
# # # # # # # # # # # # def count():
# # # # # # # # # # # #     def f(j):
# # # # # # # # # # # #         def g():
# # # # # # # # # # # #             return j*j
# # # # # # # # # # # #         return g
# # # # # # # # # # # #     fs = []
# # # # # # # # # # # #     for i in range(1, 4):
# # # # # # # # # # # #         fs.append(f(i))
# # # # # # # # # # # #     return fs
# # # # # # # # # # #
# # # # # # # # # # #
# # # # # # # # # # # def count():
# # # # # # # # # # #     def f(j):
# # # # # # # # # # #         def g():
# # # # # # # # # # #             return j * j
# # # # # # # # # # #         return g
# # # # # # # # # # #     fs = []
# # # # # # # # # # #     for i in range(1, 4):
# # # # # # # # # # #         fs.append(f(i))
# # # # # # # # # # #     return fs
# # # # # # # # # # #
# # # # # # # # # # #
# # # # # # # # # # # f1, f2, f3 = count()
# # # # # # # # # # # print(f1())
# # # # # # # # # # # print(f2())
# # # # # # # # # # # print(f3())
# # # # # # # # # # #
# # # # # # # # # #
# # # # # # # # # #
# # # # # # # # # # a = list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
# # # # # # # # # # print(a)
# # # # # # # # # # # 关键字lambda标识匿名函数，冒号前边的x表示函数的参数
# # # # # # # # # # # 匿名函数的限制：只能有一个表达式。不用写return，返回值就是表达式的结果
# # # # # # # # # # # 匿名函数的好处：不用担心函数名冲突问题
# # # # # # # # # # # 匿名函数也是一个函数对象，可以赋值给一个变量，在利用变量来调用该函数
# # # # # # # # # # f = lambda x: x * x
# # # # # # # # # # print(f(5))
# # # # # # # # # #
# # # # # # # # # #
# # # # # # # # # # # 匿名函数也可作为返回值
# # # # # # # # # # def build(x, y):
# # # # # # # # # #     return lambda: x * x + y * y
# # # # # # # # # #
# # # # # # # # # #
# # # # # # # # # # # 过滤1-20之间的奇数
# # # # # # # # # # L = list(filter(lambda n: n % 2 == 1, range(1, 20)))
# # # # # # # # # # print(L)
# # # # # # # # # #
# # # # # # # # # #
# # # # # # # # # # # 装饰器
# # # # # # # # # # def now():
# # # # # # # # # #     print('2015-3-25')
# # # # # # # # # #
# # # # # # # # # #
# # # # # # # # # # f = now
# # # # # # # # # # f()
# # # # # # # # # #
# # # # # # # # # # # 取到函数名
# # # # # # # # # # print(now.__name__)
# # # # # # # # # # print(f.__name__)
# # # # # # # # # #
# # # # # # # # # #
# # # # # # # # # # # 假设我们要增强now()函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改函数定义
# # # # # # # # # # # 这种在代码运行期间动态增加的方式，称之为"装饰器"（Decorator）
# # # # # # # # # #
# # # # # # # # # # # 本质上decorator就是一个返回函数的高阶函数
# # # # # # # # # # # 定义一个能打印日志的decorator
# # # # # # # # # # def log(func):
# # # # # # # # # #     def wrapper(*args, **kw):
# # # # # # # # # #         print('call %s():' % func.__name__)
# # # # # # # # # #         return func(*args, **kw)
# # # # # # # # # #
# # # # # # # # # #     return wrapper
# # # # # # # # # #
# # # # # # # # # #
# # # # # # # # # # # 观察上边的Log，因为decorator，所以接受一个函数作为参数，并返回一个函数
# # # # # # # # # # # 借助Python的@语法，把decorator置于函数的定义处
# # # # # # # # # # @log
# # # # # # # # # # def now():
# # # # # # # # # #     print('2015-3-25')
# # # # # # # # # #
# # # # # # # # # #
# # # # # # # # # # # 调用now()函数，不仅会运行函数的本身，还会在运行now()函数前打印一行日志
# # # # # # # # # # now()
# # # # # # # # # #
# # # # # # # # # #
# # # # # # # # # # # 由于log()是一个decorator，返回一个函数，所以，原来的now()函数依然存在，只是现在
# # # # # # # # # # # 同名的now变量指向了新函数，于是调用now()将执行新函数，即在log()函数中返回wrapper()函数
# # # # # # # # # # # wrapper()函数的参数定义是(*args, **kw),因此，wrapper()函数可以接受任意参数调用
# # # # # # # # # # # 首先打印日志，再紧接着调用原始函数
# # # # # # # # # #
# # # # # # # # # #
# # # # # # # # # # # 如果decorator本身需要传入参数，那就编写一个返回decorator的高阶函数
# # # # # # # # # # def log(text):
# # # # # # # # # #     def decorator(func):
# # # # # # # # # #         def wrapper(*args, **kw):
# # # # # # # # # #             print('%s %s():' % (text, func.__name__))
# # # # # # # # # #             return func(*args, **kw)
# # # # # # # # # #
# # # # # # # # # #         return wrapper
# # # # # # # # # #
# # # # # # # # # #     return decorator
# # # # # # # # # #
# # # # # # # # # #
# # # # # # # # # # @log('execute')
# # # # # # # # # # def now():
# # # # # # # # # #     print('2018-05-14')
# # # # # # # # # #
# # # # # # # # # #
# # # # # # # # # # now()
# # # # # # # # # # # 经过decorator装饰之后的函数，__name__变为了'wrapper'
# # # # # # # # # # print(now.__name__)
# # # # # # # # # #
# # # # # # # # # # # 所以一个完整的decorator函数，编写如下
# # # # # # # # # # import functools
# # # # # # # # # #
# # # # # # # # # #
# # # # # # # # # # def log(func):
# # # # # # # # # #     @functools.wraps(func)
# # # # # # # # # #     def wrapper(*args, **kw):
# # # # # # # # # #         print('call %s():' % func.__name__)
# # # # # # # # # #         return func(*args, **kw)
# # # # # # # # # #
# # # # # # # # # #     return wrapper
# # # # # # # # # #
# # # # # # # # # #
# # # # # # # # # # @log
# # # # # # # # # # def now():
# # # # # # # # # #     print('2018-05-21')
# # # # # # # # # #
# # # # # # # # # #
# # # # # # # # # # now()
# # # # # # # # # # print(now.__name__)
# # # # # # # # # #
# # # # # # # # # #
# # # # # # # # # # # 带参数的decorator
# # # # # # # # # # def log1(text):
# # # # # # # # # #     def decorator(func):
# # # # # # # # # #         @functools.wraps(func)
# # # # # # # # # #         def wrapper(*args, **kw):
# # # # # # # # # #             print('%s %s():' % (text, func.__name__))
# # # # # # # # # #             return func(*args, **kw)
# # # # # # # # # #
# # # # # # # # # #         return wrapper
# # # # # # # # # #
# # # # # # # # # #     return decorator
# # # # # # # # # #
# # # # # # # # # #
# # # # # # # # # # @log1('test')
# # # # # # # # # # def now():
# # # # # # # # # #     print('2018-05-21')
# # # # # # # # # #
# # # # # # # # # #
# # # # # # # # # # now()
# # # # # # # # # # print(now.__name__)
# # # # # # # # # #
# # # # # # # # # # import time, functools
# # # # # # # # # #
# # # # # # # # # #
# # # # # # # # # # def metric(fn):
# # # # # # # # # #     @functools.wraps(fn)
# # # # # # # # # #     def wrapper(*args, **kw):
# # # # # # # # # #         start = time.time()
# # # # # # # # # #         result = fn(*args, **kw)
# # # # # # # # # #         ellipsed = time.time() - start
# # # # # # # # # #         print('%s executed in %s ms' % (fn.__name__, 1000 * ellipsed))
# # # # # # # # # #         return result
# # # # # # # # # #     return wrapper
# # # # # # # # # #
# # # # # # # # # #
# # # # # # # # # # # 测试
# # # # # # # # # # @metric
# # # # # # # # # # def fast(x, y):
# # # # # # # # # #     time.sleep(0.0012)
# # # # # # # # # #     return x + y
# # # # # # # # # #
# # # # # # # # # #
# # # # # # # # # # @metric
# # # # # # # # # # def slow(x, y, z):
# # # # # # # # # #     time.sleep(0.1234)
# # # # # # # # # #     return x * y * z
# # # # # # # # # #
# # # # # # # # # #
# # # # # # # # # # f = fast(11, 22)
# # # # # # # # # # s = slow(11, 22, 33)
# # # # # # # # # # print(time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()))
# # # # # # # # # # if f != 33:
# # # # # # # # # #     print('测试失败!')
# # # # # # # # # # elif s != 7986:
# # # # # # # # # #     print('测试失败!')
# # # # # # # # # # else:
# # # # # # # # # #     print('测试成功')
# # # # # # # # #
# # # # # # # # #
# # # # # # # # # def int2(x, base=2):
# # # # # # # # #     return int(x, base)
# # # # # # # # #
# # # # # # # # #
# # # # # # # # # # int()函数提供额外参数，base将任意数字转换为任意进制的数字
# # # # # # # # # print(int2('1000000'))
# # # # # # # # # print(int2('1010101'))
# # # # # # # # #
# # # # # # # # # # 创建一个偏函数
# # # # # # # # # # functools.partial的作用是：把一个函数的某些参数固定(设置默认值),返回一个新函数，简化调用
# # # # # # # # # import functools
# # # # # # # # #
# # # # # # # # # int2 = functools.partial(int, base=2)
# # # # # # # # #
# # # # # # # # # print(int2('100000'))
# # # # # # # # #
# # # # # # # # # # 创建偏函数时，也可以接受函数对象、*args和**kw
# # # # # # # # # kw = {'base': 2}
# # # # # # # # # print(int('10101', **kw))
# # # # # # # # # # 传入函数,会把10作为*args的一部分自动添加到左边
# # # # # # # # # # 即max2(2, 5, 7)实际上是max2(10, 2, 5, 7)，打印结果为10
# # # # # # # # # max2 = functools.partial(max, 10)
# # # # # # # # # print(max2(2, 5, 7))
# # # # # # # # #
# # # # # # # # # # 当函数的参数个数太多，需要简化时，使用functools.partial可以创建一个新的函数，
# # # # # # # # # # 这个新函数可以固定住原函数的部分参数，从而在调用时更简单。
# # # # # # # # #
# # # # # # # # #
# # # # # # # #
# # # # # # # #
# # # # # # # # __author__ = 'Bike'
# # # # # # # #
# # # # # # # # import sys
# # # # # # # #
# # # # # # # #
# # # # # # # # # 内建sys模块为例，编写一个hello的模块
# # # # # # # # def test():
# # # # # # # #     args = sys.argv
# # # # # # # #     if len(args) == 1:
# # # # # # # #         print('Hello world!')
# # # # # # # #     elif len(args) == 2:
# # # # # # # #         print('Hello, %s!' % args[1])
# # # # # # # #     else:
# # # # # # # #         print('Too many arguments!')
# # # # # # # #
# # # # # # # #
# # # # # # # # if __name__ == '__main__':
# # # # # # # #     test()
# # # # # # # #
# # # # # # # #
# # # # # # # # # 正常的函数和变量名是公开的的，可以直接被引用
# # # # # # # # # 类似于_abc这样的变量是私有的，不能被直接调用
# # # # # # # # # 私有函数或变量的用法
# # # # # # # # def _private_1(name):
# # # # # # # #     return 'Hello, %s' % name
# # # # # # # #
# # # # # # # #
# # # # # # # # def _private_2(name):
# # # # # # # #     return 'Hi, %s' % name
# # # # # # # #
# # # # # # # #
# # # # # # # # def greeting(name):
# # # # # # # #     if len(name) > 3:
# # # # # # # #         return _private_1(name)
# # # # # # # #     else:
# # # # # # # #         return _private_2(name)
# # # # # # # #
# # # # # # # #
# # # # # # # # # 在模块里公开greeting()函数，把内部逻辑用private隐藏起来
# # # # # # # # print(greeting('lucy'))
# # # # # # # # print(greeting('li'))
# # # # # # # #
# # # # # # # #
# # # # # # # # # 类和实例
# # # # # # # # class Student(object):
# # # # # # # #     pass
# # # # # # # #
# # # # # # # #
# # # # # # # # # 创建实例
# # # # # # # # bart = Student()
# # # # # # # # print(bart)
# # # # # # # # print(Student)
# # # # # # # #
# # # # # # # # # 可以自由的给一个实例变量绑定属性
# # # # # # # # bart.name = 'bart Simposon'
# # # # # # # # print(bart.name)
# # # # # # # #
# # # # # # # #
# # # # # # # # # 由于类起到模板作用，所以，在创建实例的时候，把一些属性强制填写进去
# # # # # # # # # 通过__init__方法，在创建实例的时候，把name，socre等属性绑定上去
# # # # # # # # # __init__的第一个参数永远是self，表示创建的实例本身
# # # # # # # # class Student(object):
# # # # # # # #
# # # # # # # #     def __init__(self, name, score):
# # # # # # # #         self.name = name
# # # # # # # #         self.score = score
# # # # # # # #
# # # # # # # #
# # # # # # # # # 有了init方法，在创建实例的时候，就不能传入为空的参数，传入的参数必须与init中匹配
# # # # # # # # # self可以不用传入
# # # # # # # # bart = Student('mike', 60)
# # # # # # # # print(bart.name)
# # # # # # # # print(bart.score)
# # # # # # # #
# # # # # # # #
# # # # # # # # # 数据的封装
# # # # # # # # def print_score(std):
# # # # # # # #     print('%s: %s' % (std.name, std.score))
# # # # # # # #
# # # # # # # #
# # # # # # # # print_score(bart)
# # # # # # # #
# # # # # # # #
# # # # # # # # # 定义类的方法
# # # # # # # # class Student(object):
# # # # # # # #
# # # # # # # #     def __init__(self, name, score):
# # # # # # # #         self.name = name
# # # # # # # #         self.score = score
# # # # # # # #
# # # # # # # #     def print_score(self):
# # # # # # # #         print('%s: %s' % (self.name, self.score))
# # # # # # # #
# # # # # # # #     # 数据封装的另一个好处是可以给Student增加新方法
# # # # # # # #     def get_grade(self):
# # # # # # # #         if self.score >= 90:
# # # # # # # #             return 'A'
# # # # # # # #         elif self.score >= 60:
# # # # # # # #             return 'B'
# # # # # # # #         else:
# # # # # # # #             return 'C'
# # # # # # # #
# # # # # # # #
# # # # # # # # bart = Student('lucy', 80)
# # # # # # # # bart.print_score()
# # # # # # # # print(bart.name, bart.get_grade())
# # # # # # # #
# # # # # # # # # 访问限制
# # # # # # # # # 此处实例的score属性被修改
# # # # # # # # bart.score = 99
# # # # # # # # print(bart.score)
# # # # # # # #
# # # # # # # #
# # # # # # # # # 如果不想让属性被修改，在属性前边加上两个下划线__，即变成了私有变量
# # # # # # # # # 只有内部可以访问，外部不能访问
# # # # # # # # class Student(object):
# # # # # # # #
# # # # # # # #     def __init__(self, name, score):
# # # # # # # #         self.__name = name
# # # # # # # #         self.__score = score
# # # # # # # #
# # # # # # # #     def print_score(self):
# # # # # # # #         print('%s: %s' % (self.__name, self.__score))
# # # # # # # #
# # # # # # # #     # 外部获取属性的方法
# # # # # # # #     def get_name(self):
# # # # # # # #         return self.__name
# # # # # # # #
# # # # # # # #     def get_score(self):
# # # # # # # #         return self.__score
# # # # # # # #
# # # # # # # #     # 允许外界修改类的属性
# # # # # # # #     # 将类的属性设置为私有的，通过set，get方法可以对参数进行检验，避免无效的参数
# # # # # # # #     def set_score(self, score):
# # # # # # # #         if 0 <= score <= 100:
# # # # # # # #             self.__score = score
# # # # # # # #         else:
# # # # # # # #             raise ValueError('bad score')
# # # # # # # #
# # # # # # # #
# # # # # # # # bart = Student('kirk', 78)
# # # # # # # # bart.print_score()
# # # # # # # # # 此时已经不能再调用类的属性
# # # # # # # # # print(bart.__name)
# # # # # # # # # 利用类方法调用访问类的属性
# # # # # # # # print(bart.get_name())
# # # # # # # # # 利用类的方法修改类的属性
# # # # # # # # bart.set_score(66)
# # # # # # # # print(bart.get_score())
# # # # # # # # # 此处传入的分数超过100，引起报错
# # # # # # # # # print(bart.set_score(109))
# # # # # # # #
# # # # # # # # # 变量名__xxx__，是特殊变量可以直接访问，所以，不能定义__name__，__socre__这样的变量
# # # # # # # # # 有些时候，你会看到以一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的
# # # # # # # # # 但是，按照约定俗成的规定，当你看到这样的变量时
# # # # # # # # # 意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”
# # # # # # # #
# # # # # # # # # __name也可以从外部获取到值
# # # # # # # # # 不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，
# # # # # # # # # 所以，仍然可以通过_Student__name来访问__name变量
# # # # # # # #
# # # # # # # # # 但是强烈建议你不要这么干，因为不同版本的Python解释器可能会把__name改成不同的变量名。
# # # # # # # # print(bart._Student__name)
# # # # # # # #
# # # # # # # #
# # # # # # # # # 作业
# # # # # # # # # 请把下面的Student对象的gender字段对外隐藏起来
# # # # # # # # # 用get_gender()和set_gender()代替，并检查参数有效性
# # # # # # # # class Student(object):
# # # # # # # #     def __init__(self, name, gender):
# # # # # # # #         self.name = name
# # # # # # # #         self.__gender = gender
# # # # # # # #
# # # # # # # #     def get_gender(self):
# # # # # # # #         return self.__gender
# # # # # # # #
# # # # # # # #     def set_gender(self, gender):
# # # # # # # #         if gender == 'male' or gender == 'female':
# # # # # # # #             self.__gender = gender
# # # # # # # #         else:
# # # # # # # #             raise ValueError('bad score')
# # # # # # # #
# # # # # # # #
# # # # # # # # # 测试:
# # # # # # # # bart = Student('Bart', 'male')
# # # # # # # # if bart.get_gender() != 'male':
# # # # # # # #     print('测试失败!')
# # # # # # # # else:
# # # # # # # #     bart.set_gender('female')
# # # # # # # #     if bart.get_gender() != 'female':
# # # # # # # #         print('测试失败!')
# # # # # # # #     else:
# # # # # # # #         print('测试成功!')
# # # # # # # #
# # # # # # # #
# # # # # # # # # 继承和多态
# # # # # # # # # 定义一个animal类
# # # # # # # # class Animal(object):
# # # # # # # #
# # # # # # # #     def run(self):
# # # # # # # #         print('Animal is running...')
# # # # # # # #
# # # # # # # #
# # # # # # # # # 写dog，cat类继承与Animal类
# # # # # # # # class Dog(Animal):
# # # # # # # #     pass
# # # # # # # #
# # # # # # # #
# # # # # # # # class Cat(Animal):
# # # # # # # #     pass
# # # # # # # #
# # # # # # # #
# # # # # # # # # 试运行子类
# # # # # # # # dog = Dog()
# # # # # # # # dog.run()
# # # # # # # #
# # # # # # # #
# # # # # # # # # 增加子类方法
# # # # # # # # class Dog(Animal):
# # # # # # # #
# # # # # # # #     def run(self):
# # # # # # # #         print('Dog is running...')
# # # # # # # #
# # # # # # # #     def eat(self):
# # # # # # # #         print('Eating meat...')
# # # # # # # #
# # # # # # # #
# # # # # # # # # 子类的方法会覆盖父类的方法
# # # # # # # # # 在代码运行的时候，总是会调用子类的run()。这样，我们就获得了继承的另一个好处：多态
# # # # # # # # dog = Dog()
# # # # # # # # dog.run()
# # # # # # # # dog.eat()
# # # # # # # #
# # # # # # # # # 判断变量是否归属于某个类型
# # # # # # # # a = list()
# # # # # # # # b = Animal()
# # # # # # # # c = Dog()
# # # # # # # #
# # # # # # # # print(isinstance(c, Dog))
# # # # # # # # print(isinstance(c, list))
# # # # # # # # # 子类的变量也可以归于父类
# # # # # # # # print(isinstance(c, Animal))
# # # # # # # #
# # # # # # # #
# # # # # # # # # 对于Python这样的动态语言来说，
# # # # # # # # # 则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了：
# # # # # # # # class Student():
# # # # # # # #     def grade(self):
# # # # # # # #         print('哇要考试啦！')
# # # # # # # #
# # # # # # # #
# # # # # # # # class goodStudent(Student):
# # # # # # # #     def grade(self):
# # # # # # # #         print('哇满分！')
# # # # # # # #
# # # # # # # #
# # # # # # # # class badStudent(Student):
# # # # # # # #     def grade(self):
# # # # # # # #         print('哇零分')
# # # # # # # #
# # # # # # # #
# # # # # # # # class Pig():
# # # # # # # #     def grade(self):
# # # # # # # #         print('精品猪肉！')
# # # # # # # #
# # # # # # # #
# # # # # # # # def kind(student):
# # # # # # # #     student.grade()
# # # # # # # #
# # # # # # # #
# # # # # # # # student = Student()
# # # # # # # # good = goodStudent()
# # # # # # # # bad = badStudent()
# # # # # # # # pig = Pig()
# # # # # # # # kind(student)
# # # # # # # # kind(good)
# # # # # # # # kind(bad)
# # # # # # # # kind(pig)
# # # # # # # #
# # # # # # # #
# # # # # # # #
# # # # # # #
# # # # # # #
# # # # # # # print(type('123'))
# # # # # # # # 获取对象信息
# # # # # # # # 判断对象的类型
# # # # # # #
# # # # # # # # 如果一个变量指向函数或者类，也可以用type()判断
# # # # # # # print(type(abs))
# # # # # # #
# # # # # # # # 可以判断两个变量的类型是否相同
# # # # # # # print(type(123) == type(456))
# # # # # # #
# # # # # # # # 判断一个对象是否是函数
# # # # # # # import types
# # # # # # #
# # # # # # #
# # # # # # # def fn():
# # # # # # #     pass
# # # # # # #
# # # # # # #
# # # # # # # print(type(fn) == types.FunctionType)
# # # # # # # print(type(abs) == types.BuiltinFunctionType)
# # # # # # # print(type(lambda x: x) == types.LambdaType)
# # # # # # # print(type((x for x in range(10))) == types.GeneratorType)
# # # # # # #
# # # # # # # # 使用instance来判断类型
# # # # # # # print(isinstance('a', str))
# # # # # # # print(isinstance(123, float))
# # # # # # # # 判断一个变量是否是某些类型中的一种
# # # # # # # # 总是优先使用isinstance()判断类型，可以将指定类型及其子类“一网打尽”
# # # # # # # print(isinstance([1, 2, 3], (list, tuple)))
# # # # # # #
# # # # # # # # 使用dir()
# # # # # # # # 如果要获得一个对象的所有属性和方法，使用dir()
# # # # # # # # 它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法
# # # # # # # # print(dir('qwer'))
# # # # # # #
# # # # # # # # 系统的len()函数等价于下面的函数
# # # # # # # print(len('abc'))
# # # # # # # print('abc'.__len__())
# # # # # # #
# # # # # # #
# # # # # # # # 所以可以自己定义系统方法
# # # # # # # class MyDog(object):
# # # # # # #     def __len__(self):
# # # # # # #         return 100
# # # # # # #
# # # # # # #
# # # # # # # dog = MyDog()
# # # # # # # print(len(dog))
# # # # # # #
# # # # # # # # 普通属性或方法
# # # # # # # print('ABC'.lower())
# # # # # # #
# # # # # # #
# # # # # # # # 配合getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态
# # # # # # # class MyObject(object):
# # # # # # #     def __init__(self):
# # # # # # #         self.x = 9
# # # # # # #
# # # # # # #     def power(self):
# # # # # # #         return self.x * self.x
# # # # # # #
# # # # # # #
# # # # # # # obj = MyObject()
# # # # # # #
# # # # # # # # 测试该对象的属性
# # # # # # # # 是否具有属性x
# # # # # # # print(hasattr(obj, 'x'))
# # # # # # # # 打印属性的值
# # # # # # # print(obj.x)
# # # # # # # # 添加一个属性y
# # # # # # # setattr(obj, 'y', 19)
# # # # # # # # 获取新添加的属性
# # # # # # # print(getattr(obj, 'y'))
# # # # # # # # 打印新添加的属性
# # # # # # # print(obj.y)
# # # # # # # # 设置不存在的属相报错显示，z不存在，报错404
# # # # # # # print(obj, 'z', 404)
# # # # # # # # 获取对象的方法
# # # # # # # print(hasattr(obj, 'power'))
# # # # # # # # 获取属性power
# # # # # # # print(obj, 'power')
# # # # # # # # 获取属性power并赋值到变量fn
# # # # # # # fn = getattr(obj, 'power')
# # # # # # # print(fn)
# # # # # # # # 调用fn
# # # # # # # print(fn())
# # # # # # #
# # # # # # #
# # # # # # # # 实例类和类属性
# # # # # # # # 由于Python是动态语言，根据类的创建的实例可以任意绑定属性
# # # # # # # class Student(object):
# # # # # # #     def __init__(self, name):
# # # # # # #         self.name = name
# # # # # # #
# # # # # # #
# # # # # # # s = Student('Bob')
# # # # # # # # 添加一个score属性
# # # # # # # s.score = 90
# # # # # # # print(s.score)
# # # # # # #
# # # # # # #
# # # # # # # # name是类属性，归Student所有
# # # # # # # class Student(object):
# # # # # # #     name = 'Student'
# # # # # # #
# # # # # # #
# # # # # # # # 类的所有实例都可以访问这个归属属性
# # # # # # # s = Student()
# # # # # # # # 使用实例来访问属性
# # # # # # # print(s.name)
# # # # # # # # 使用类来访问属性
# # # # # # # print(Student.name)
# # # # # # # # 给实例绑定属性
# # # # # # # s.name = 'mike'
# # # # # # # # 实例属性优先级比类属性高，屏蔽了类的name属性
# # # # # # # print(s.name)
# # # # # # # # 但是类的属性未消失
# # # # # # # print(Student.name)
# # # # # # # # 删除实例的属性,类的属性也可被删除
# # # # # # # del s.name
# # # # # # # # del Student.name
# # # # # # # print(s.name)
# # # # # # #
# # # # # # #
# # # # # # # class Student(object):
# # # # # # #     count = 0
# # # # # # #
# # # # # # #     def __init__(self, name):
# # # # # # #         self.name = name
# # # # # # #         Student.count += 1
# # # # # # #
# # # # # # #
# # # # # # # # 测试:
# # # # # # # if Student.count != 0:
# # # # # # #     print('测试失败!')
# # # # # # # else:
# # # # # # #     bart = Student('Bart')
# # # # # # #     if Student.count != 1:
# # # # # # #         print('测试失败!')
# # # # # # #     else:
# # # # # # #         lisa = Student('Bart')
# # # # # # #         if Student.count != 2:
# # # # # # #             print('测试失败!')
# # # # # # #         else:
# # # # # # #             print('Students:', Student.count)
# # # # # # #             print('测试通过!')
# # # # # # #
# # # # # # #
# # # # # #
# # # # # # # class Student(object):
# # # # # # #     pass
# # # # # # #
# # # # # # #
# # # # # # # # 使用__slots__
# # # # # # # s = Student()
# # # # # # # # 绑定一个实例属性
# # # # # # # s.age = 10
# # # # # # # print(s.age)
# # # # # # #
# # # # # # #
# # # # # # # # 给实例绑定一个方法
# # # # # # # def set_age(self, age):
# # # # # # #     self.age = age
# # # # # # #
# # # # # # #
# # # # # # # from types import MethodType
# # # # # # #
# # # # # # # # 给实例绑定一个方法
# # # # # # # s.set_age = MethodType(set_age, s)
# # # # # # # s.set_age(12)
# # # # # # # print(s.age)
# # # # # # #
# # # # # # # # 对实例绑定的方法在另一个新建的实例上不起作用
# # # # # # # s2 = Student()
# # # # # # #
# # # # # # #
# # # # # # # # s2.set_age(13)
# # # # # # #
# # # # # # #
# # # # # # # # 但是在类中定义方法，可以让所有的实例都绑定上
# # # # # # # def set_score(self, score):
# # # # # # #     self.score = score
# # # # # # #
# # # # # # #
# # # # # # # # 类方法绑定
# # # # # # # Student.set_score = set_score
# # # # # # # # 调用类的方法
# # # # # # # s2.set_score(100)
# # # # # # # print(s2.score)
# # # # # # #
# # # # # # #
# # # # # # # # 通过使用__slots__来限制实例类的属性
# # # # # # # # 只允许Student添加name和score
# # # # # # # class Student(object):
# # # # # # #     __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称
# # # # # # #
# # # # # # #
# # # # # # # # 创建新的实例
# # # # # # # s = Student()
# # # # # # # # 绑定属性
# # # # # # # s.name = 'mike'
# # # # # # # s.age = 12
# # # # # # # # 绑定额外的score属性,score没在tuple中，所以会报错
# # # # # # # # s.score = 100
# # # # # # #
# # # # # # #
# # # # # # # # 使用__slots__要注意，__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的：
# # # # # # # class GraduateStudent(Student):
# # # # # # #     pass
# # # # # # #
# # # # # # #
# # # # # # # g = GraduateStudent()
# # # # # # # g.score = 100
# # # # # #
# # # # # #
# # # # # # class Student(object):
# # # # # #
# # # # # #     # 使用@property，把一个方法变成属性来调用
# # # # # #     @property
# # # # # #     def score(self):
# # # # # #         return self._score
# # # # # #
# # # # # #     @score.setter
# # # # # #     def score(self, value):
# # # # # #         if not isinstance(value, int):
# # # # # #             raise ValueError('score must be an integer!')
# # # # # #         if value < 0 or value > 100:
# # # # # #             raise ValueError('score must be between 0 ~ 100!')
# # # # # #         self._score = value
# # # # # #
# # # # # #
# # # # # # s = Student()
# # # # # # s.score = 60  # 实际转化为s.set_score(60)
# # # # # # print(s.score)  # 实际转化为s.get_score()
# # # # # #
# # # # # #
# # # # # # # s.score = 9999  # 传入的参数超出界定的范围
# # # # # #
# # # # # #
# # # # # # # 设置只读属性
# # # # # # class Student(object):
# # # # # #
# # # # # #     @property  # 只加@property的话，相当只设置了属性的getter方法，即已读属性
# # # # # #     def birth(self):
# # # # # #         return self._birth
# # # # # #
# # # # # #     @birth.setter  # 添加setter属性，操作属性
# # # # # #     def birth(self, value):
# # # # # #         self._birth = value
# # # # # #
# # # # # #     @property
# # # # # #     def age(self):
# # # # # #         return 2015 - self._birth
# # # # # #
# # # # # #
# # # # # # # 请利用@property给一个Screen对象加上width和height属性，以及一个只读属性resolution：
# # # # # # class Screen(object):
# # # # # #
# # # # # #     @property
# # # # # #     def width(self):
# # # # # #         return self._width
# # # # # #
# # # # # #     @width.setter
# # # # # #     def width(self, value):
# # # # # #         self._width = value
# # # # # #
# # # # # #     @property
# # # # # #     def height(self):
# # # # # #         return self._height
# # # # # #
# # # # # #     @height.setter
# # # # # #     def height(self, value):
# # # # # #         self._height = value
# # # # # #
# # # # # #     @property
# # # # # #     def resolution(self):
# # # # # #         return self._width * self._height
# # # # # #
# # # # # #
# # # # # # # 测试:
# # # # # # s = Screen()
# # # # # # s.width = 1024
# # # # # # s.height = 768
# # # # # # print('resolution =', s.resolution)
# # # # # # if s.resolution == 786432:
# # # # # #     print('测试通过!')
# # # # # # else:
# # # # # #     print('测试失败!')
# # # # # #
# # # # # #
# # # # # # # 多重继承
# # # # # # class Animal(object):
# # # # # #     pass
# # # # # #
# # # # # #
# # # # # # # 大类,Mammal:哺乳动物
# # # # # # class Mammal(Animal):
# # # # # #     pass
# # # # # #
# # # # # #
# # # # # # class Bird(Animal):
# # # # # #     pass
# # # # # #
# # # # # #
# # # # # # # 各种动物
# # # # # # class Dog(Mammal):
# # # # # #     pass
# # # # # #
# # # # # #
# # # # # # class Bat(Mammal):
# # # # # #     pass
# # # # # #
# # # # # #
# # # # # # # 鹦鹉
# # # # # # class Parrot(Bird):
# # # # # #     pass
# # # # # #
# # # # # #
# # # # # # # 鸵鸟
# # # # # # class Ostrich(Bird):
# # # # # #     pass
# # # # # #
# # # # # #
# # # # # # # 加上Runnable和Flyable
# # # # # # class Runnable(object):
# # # # # #     def run(self):
# # # # # #         print('Running...')
# # # # # #
# # # # # #
# # # # # # class Flyable(object):
# # # # # #     def fly(self):
# # # # # #         print('Flying...')
# # # # # #
# # # # # #
# # # # # # # 需要runnable功能的动物，多继承一个Runnable
# # # # # # class Dog(Mammal, Runnable):
# # # # # #     pass
# # # # # #
# # # # # #
# # # # # # # 通过多重继承，一个子类就能获取多个父类的所有功能
# # # # # #
# # # # # # # MixIn：通常，主线都是单一继承下来的，例如，Ostrich继承自Bird。\
# # # # # # # 但是，如果需要“混入”额外的功能，通过多重继承就可以实现，\
# # # # # # # 比如，让Ostrich除了继承自Bird外，再同时继承Runnable
# # # # # # # 这种设计通常称之为MixIn
# # # # # #
# # # # # # # Python自带的很多库也使用了MixIn。\
# # # # # # # 举个例子，Python自带了TCPServer和UDPServer这两类网络服务，\
# # # # # # # 而要同时服务多个用户就必须使用多进程或多线程模型，\
# # # # # # # 这两种模型由ForkingMixIn和ThreadingMixIn提供。\
# # # # # # # 通过组合，我们就可以创造出合适的服务来。
# # # # # #
# # # # # # # 例如编写一个多进程的TCP服务
# # # # # # # class MyTCPServer(TCPServer, ForkingMixIn):
# # # # # # #     pass
# # # # # #
# # # # # #
# # # # # # # 定制类：
# # # # # # class Student(object):
# # # # # #     def __init__(self, name):
# # # # # #         self.name = name
# # # # # #
# # # # # #
# # # # # # print(Student('mike'))
# # # # # #
# # # # # #
# # # # # # # 利用__str__来返回一个规定字符串
# # # # # # class Student(object):
# # # # # #     def __init__(self, name):
# # # # # #         self.name = name
# # # # # #
# # # # # #     def __str__(self):
# # # # # #         return 'Student object (name: %s)' % self.name
# # # # # #
# # # # # #
# # # # # # print(Student('bob'))
# # # # # # s = Student('jack')
# # # # # # print(s)
# # # # # #
# # # # # #
# # # # # # # __iter__：类似于循环for...in
# # # # # # class Fib(object):
# # # # # #     def __init__(self):
# # # # # #         self.a, self.b = 0, 1  # 初始化两个计数器a，b
# # # # # #
# # # # # #     def __iter__(self):
# # # # # #         return self  # 实例本身就是迭代对象，故返回自己
# # # # # #
# # # # # #     def __next__(self):
# # # # # #         self.a, self.b = self.b, self.a + self.b  # 计算下一个值
# # # # # #         if self.a > 100000:  # 设置退出循环条件
# # # # # #             raise StopIteration()
# # # # # #         return self.a
# # # # # #
# # # # # #
# # # # # # for n in Fib():
# # # # # #     print(n)
# # # # # #
# # # # # #
# # # # # # # __getitem__: 取出__iter__中的元素
# # # # # # class Fib(object):
# # # # # #     def __getitem__(self, n):
# # # # # #         a, b = 1, 1
# # # # # #         for x in range(n):
# # # # # #             a, b = b, a + b
# # # # # #         return a
# # # # # #
# # # # # #
# # # # # # # 取出任一特定的元素
# # # # # # f = Fib()
# # # # # # print(f[0])
# # # # # # print(f[3])
# # # # # #
# # # # # #
# # # # # # # 但是这个方法不能进行切片操作，想要进行进行切片需要进一步完善功能
# # # # # # class Fib(object):
# # # # # #     def __getitem__(self, n):
# # # # # #         if isinstance(n, int):  # n是索引
# # # # # #             a, b = 1, 1
# # # # # #             for x in range(n):
# # # # # #                 a, b = b, a + b
# # # # # #             return a
# # # # # #         if isinstance(n, slice):  # n是切片
# # # # # #             start = n.start
# # # # # #             stop = n.stop
# # # # # #             if start is None:
# # # # # #                 start = 0
# # # # # #             a, b = 1, 1
# # # # # #             L = []
# # # # # #             for x in range(stop):
# # # # # #                 if x >= start:
# # # # # #                     L.append(a)
# # # # # #                 a, b = b, a + b
# # # # # #             return L
# # # # # #
# # # # # #
# # # # # # # 实验Fib的切片
# # # # # # f = Fib()
# # # # # # print(f[0:5])
# # # # # #
# # # # # #
# # # # # # # 此方法没有对负数做处理。所以，实现一个__getitem__需要做很多的工作
# # # # # # # 与之对应的是__setitem__()方法，把对象视作list或dict来对集合赋值\
# # # # # # # 最后，还有一个__delitem__()方法，用于删除某个元素。
# # # # # #
# # # # # #
# # # # # # # __getattr__：使用此属性，动态返回一个属性
# # # # # # class Student(object):
# # # # # #
# # # # # #     def __init__(self):
# # # # # #         self.name = 'mike'
# # # # # #
# # # # # #
# # # # # # # 调用不存在的score，此时就会报错
# # # # # # s = Student()
# # # # # # # 调用name属性
# # # # # # print(s.name)
# # # # # #
# # # # # #
# # # # # # # 调用不存在的score属性
# # # # # # # print(s.score)
# # # # # #
# # # # # # # 动态返回属性
# # # # # # class Student(object):
# # # # # #
# # # # # #     def __init__(self):
# # # # # #         self.name = 'Bob'
# # # # # #
# # # # # #     def __getattr__(self, item):
# # # # # #         if item == 'score':
# # # # # #             return 99
# # # # # #
# # # # # #
# # # # # # s = Student()
# # # # # # print(s.score)
# # # # # #
# # # # # #
# # # # # # # 也可返回一个函数
# # # # # # class Student(object):
# # # # # #
# # # # # #     def __getattr__(self, item):
# # # # # #         if item == 'age':
# # # # # #             return lambda: 25
# # # # # #
# # # # # #
# # # # # # s = Student()
# # # # # # print(s.age())
# # # # # #
# # # # # # # 在没有找到属性的情况下，才会从__getattr__中寻找，例如，name已有属性，不会寻找
# # # # # #
# # # # # #
# # # # # # # 此外，注意到任意调用如s.abc都会返回None，这是因为我们定义的__getattr__默认返回就是None。\
# # # # # # # 要让class只响应特定的几个属性，我们就要按照约定，抛出AttributeError的错误：
# # # # # # class Student(object):
# # # # # #
# # # # # #     def __getattr__(self, item):
# # # # # #         if item == 'age':
# # # # # #             return lambda: 25
# # # # # #         raise AttributeError('\'Student\' object has no attribution\
# # # # # #         \'%s\'' % item)
# # # # # #
# # # # # #
# # # # # # s = Student()
# # # # # # # 错误示例，打印自定义报错信息
# # # # # # # print(s.ag())
# # # # # #
# # # # # #
# # # # # # # 利用完全动态__getattr__，写出一个链式调用
# # # # # # # 因为.的应用，在__getattr__会动态的处理添加的字串
# # # # # # # __repr__是面对程序员打印的，__str__是面对用户的
# # # # # # class China(object):
# # # # # #
# # # # # #     def __init__(self, path=''):
# # # # # #         self._path = path
# # # # # #
# # # # # #     def __getattr__(self, path):
# # # # # #         return China('%s/%s' % (self._path, path))
# # # # # #
# # # # # #     def __getattr__(self, path):
# # # # # #         if path == 'users':
# # # # # #             China('%s/%s' % (self._path, path))
# # # # # #             return lambda s: China('%s/%s' % (self._path, s))
# # # # # #         return China('%s/%s' % (self._path, path))
# # # # # #
# # # # # #     def __str__(self):
# # # # # #         return self._path
# # # # # #
# # # # # #     __repr__ = __str__
# # # # # #
# # # # # #
# # # # # # # 链式程序调用
# # # # # # print(China().status.user.timeline.list)
# # # # # # # 修改参数
# # # # # # print(China().status.users('Bob').timeline.list)
# # # # # #
# # # # # #
# # # # # # # __call__直接调用实例本身，只需要定义一个__call__即可
# # # # # # class Student(object):
# # # # # #
# # # # # #     def __init__(self, name):
# # # # # #         self.name = name
# # # # # #
# # # # # #     def __call__(self):
# # # # # #         print('My name is %s.' % self.name)
# # # # # #
# # # # # #
# # # # # # s = Student('Bob')
# # # # # # s()
# # # # # #
# # # # # # # 利用callable()函数，判断一个对象是否是"可调用"对象
# # # # # # print(callable(Student))
# # # # # # print(callable(max))
# # # # # # print(callable([1, 2, 3]))
# # # # # # print(callable('str'))
# # # # # #
# # # # # #
# # # # #
# # # # #
# # # # # # from enum import Enum
# # # # # #
# # # # # # # 枚举类：
# # # # # # Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May',
# # # # # #                        'Jun', 'Jul', 'Aug', 'Sep', 'Oct',
# # # # # #                        'Nov', 'Dec'))
# # # # # # # 直接使用Month.Jan来引用一个常量，或者枚举它的所有成员
# # # # # # # value属性是自动赋给成员的int常量，默认从1开始计数
# # # # # # for name, member in Month.__members__.items():
# # # # # #     print(name, '=>', member, ',', member.value)
# # # # # #
# # # # # #
# # # # # # # Enum派生自定义类，来更精准的控制枚举类型
# # # # # # from enum import Enum, unique
# # # # # #
# # # # # #
# # # # # # # unique装饰器可以帮助我们检查有没有重复值
# # # # # # @unique
# # # # # # class Weekday(Enum):
# # # # # #     sun = 0  # sun的Value被设定为0
# # # # # #     Mon = 1
# # # # # #     Tue = 2
# # # # # #     Wed = 3
# # # # # #     Thu = 4
# # # # # #     Fri = 5
# # # # # #     Sat = 6
# # # # # #
# # # # # #
# # # # # # # 访问枚举类型
# # # # # # day1 = Weekday.Mon
# # # # # # print(day1)
# # # # # # print(Weekday['Tue'])
# # # # # # print(Weekday.Tue.value)
# # # # # # print(Weekday.Mon == day1)
# # # # # # print(Weekday(1))
# # # # # #
# # # # # # for name, member in Weekday.__members__.items():
# # # # # #     print(name, '=>', member)
# # # # # #
# # # # # #
# # # # # # class Gender(Enum):
# # # # # #     Male = 0
# # # # # #     Female = 1
# # # # # #
# # # # # #
# # # # # # class Student(object):
# # # # # #
# # # # # #     def __init__(self, name, gender):
# # # # # #         self.name = name
# # # # # #         self.gender = gender
# # # # # #
# # # # # #
# # # # # # # 测试:
# # # # # # bart = Student('Bart', Gender.Male)
# # # # # # if bart.gender == Gender.Male:
# # # # # #     print('测试通过!')
# # # # # # else:
# # # # # #     print('测试失败!')
# # # # #
# # # # #
# # # # # # 使用元类
# # # # # # 动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的
# # # # # # 而是运行时动态创建的
# # # # # # 创建class的方法：使用type()函数
# # # # # # 首先定义函数
# # # # # # def fn(self, name='world'):
# # # # # #     print('Hello, %s' % name)
# # # # # #
# # # # # #
# # # # # # # 动态创建类
# # # # # # Hello = type('Hello', (object,), dict(hello=fn))
# # # # # # h = Hello()
# # # # # # h.hello()
# # # # # #
# # # # # #
# # # # # # # metaclass：先定义metaclass，再创建类，最后创建实例
# # # # # # # metaclass类名总是以Metaclass结尾，以便于区分
# # # # # # class ListMetaclass(type):
# # # # # #
# # # # # #     def __new__(cls, name, bases, attrs):
# # # # # #         attrs['add'] = lambda self, value: self.append(value)
# # # # # #         return type.__new__(cls, name, bases, attrs)
# # # # # #
# # # # # #
# # # # # # # 有了ListMetaclass，我们在定义类的时候还要指示使用ListMetaclass来定制类
# # # # # # # 传入关键字参数metaclass：
# # # # # # class MyList(list, metaclass=ListMetaclass):
# # # # # #     pass
# # # # # #
# # # # # #
# # # # # # L = MyList()
# # # # # # L.add(1)
# # # # # # print(L)
# # # # #
# # # # # print('')
# # # # #
# # # # #
# # # # # # 定义一个Field类，负责保存数据库的字段名和字段类型
# # # # # class Field(object):
# # # # #
# # # # #     def __init__(self, name, column_type):
# # # # #         self.name = name
# # # # #         self.column_type = column_type
# # # # #
# # # # #     def __str__(self):
# # # # #         return '<%s:%s>' % (self.__class__.__name__, self.name)
# # # # #
# # # # #
# # # # # # 在Field的基础上，进一步定义各种类型的Field
# # # # # class StringField(Field):
# # # # #
# # # # #     def __init__(self, name):
# # # # #         super(StringField, self).__init__(name, 'varchar(100)')
# # # # #
# # # # #
# # # # # class IntegerField(Field):
# # # # #
# # # # #     def __init__(self, name):
# # # # #         super(IntegerField, self).__init__(name, 'bigiht')
# # # # #
# # # # #
# # # # # # 编写metaclass
# # # # # class ModelMetaclass(type):
# # # # #
# # # # #     def __new__(cls, name, bases, attrs):
# # # # #         if name == 'Model':
# # # # #             return type.__new__(cls, name, bases, attrs)
# # # # #         print('Found model: %s' % name)
# # # # #         mappings = dict()
# # # # #         for k, v in attrs.items():
# # # # #             if isinstance(v, Field):
# # # # #                 print('Found mapping: %s ==> %s' % (k, v))
# # # # #                 mappings[k] = v
# # # # #         for k in mappings.keys():
# # # # #             attrs.pop(k)
# # # # #         attrs['__mappings__'] = mappings
# # # # #         attrs['__table__'] = name
# # # # #         return type.__new__(cls, name, bases, attrs)
# # # # #
# # # # #
# # # # # # 基类Model
# # # # # class Model(dict, metaclass=ModelMetaclass):
# # # # #
# # # # #     def __init__(self, **kw):
# # # # #         super(Model, self).__init__(**kw)
# # # # #
# # # # #     def __getattr__(self, key):
# # # # #         try:
# # # # #             return self[key]
# # # # #         except KeyError:
# # # # #             raise AttributeError(r"'Model' object has no \
# # # # #             attribute '%s'" % key)
# # # # #
# # # # #     def __setattr__(self, key, value):
# # # # #         self[key] = value
# # # # #
# # # # #     def save(self):
# # # # #         fields = []
# # # # #         params = []
# # # # #         args = []
# # # # #         for k, v in self.__mappings__.items():
# # # # #             fields.append(v.name)
# # # # #             params.append('?')
# # # # #             args.append(getattr(self, k, None))
# # # # #         sql = 'insert into %s (%s) value (%s)' % (self.__table__,
# # # # #                                                   ','.join(fields)
# # # # #                                                   .join(params))
# # # # #         print('SQL: %s' % sql)
# # # # #         print("ARGS: %s" % str(args))
# # # # #
# # # # #
# # # # # u = User(id=12345, name='Michael', email='test@orm.org',
# # # # #           password='my-pwd')
# # # # # u.save()
# # # # #
# # # #
# # # #
# # # # # def foo():
# # # # #     # r = some_function()  #此处的some_function还未定义
# # # # #     if r == (-1):
# # # # #         return (-1)
# # # # #     return r
# # # # #
# # # # #
# # # # # def bar():
# # # # #     r = foo()
# # # # #     if r == (-1):
# # # # #         print('Error')
# # # # #     else:
# # # # #         pass
# # # #
# # # #
# # # # # 以上的代码，用错误码来表示是否出错十分不便，
# # # # # 因为函数本身应该返回的正常结果和错误码混在一起，
# # # # # 造成调用者必须用大量的代码来判断是否出错：
# # # #
# # # #
# # # # # 所以通常使用try语法来处理错误
# # # # # 此处代码10/0有错误，所以result不会被打印，而是直接跳到错误的代码处
# # # # # 改为2则正常执行
# # # # # try:
# # # # #     print('try...')
# # # # #     r = 10 / 2
# # # # #     print('result:', r)
# # # # # except ZeroDivisionError as e:
# # # # #     print('except:', e)
# # # # # finally:
# # # # #     print('finally...')
# # # # # print('END')
# # # #
# # # #
# # # # # 使用except来捕获不同类型的错误
# # # # # try:
# # # # #     print('try...')
# # # # #     r = 10 / int('a')
# # # # #     print('result:', r)
# # # # # except ValueError as e:
# # # # #     print('ValueError:', e)
# # # # # except ZeroDivisionError as e:
# # # # #     print('ZeroDivisionError:', e)
# # # # # finally:
# # # # #     print('finally...')
# # # # # print('END')
# # # #
# # # #
# # # # # Python的错误也是class，所有都继承自BaseException
# # # # # 使用except，不但捕获错误，还将子类也全算上
# # # # # 下边的程序中，第二个except永远也捕捉不到错误
# # # # # 因为UnicodeError是ValueError的子类，假如有就被第一个拦截了，程序终止
# # # # # BaseException错误类型和继承关系：
# # # # # https://docs.python.org/3/library/exceptions.
# # # # # html#exception-hierarchy
# # # # # try:
# # # # #     foo()
# # # # # except ValueError as e:
# # # # #     print('ValueError:')
# # # # # except UnicodeError as e:
# # # # #     print('UnicodeError')
# # # #
# # # #
# # # # # 使用try...except捕获错误可以跨越多层调用
# # # # # 在合适的层次中调用就可以捕获别处的错误，不用精确定位
# # # # # def foo(s):
# # # # #     return 10 / int(s)
# # # # #
# # # # #
# # # # # def bar(s):
# # # # #     return foo(s) * 2
# # # # #
# # # # #
# # # # # def main():
# # # # #     try:
# # # # #         bar('0')
# # # # #     except Exception as e:
# # # # #         print('Error:', e)
# # # # #     finally:
# # # # #         print('finally...')
# # # #
# # # #
# # # # # 调用main
# # # # # main()
# # # #
# # # # # 调用栈：异常栈，报错误的日志信息
# # # # # 如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获，
# # # # # 打印一个错误信息，然后程序退出。来看看err.py：
# # # # # def foo(s):
# # # # #     return 10 / int(s)
# # # # #
# # # # #
# # # # # def bar(s):
# # # # #     return foo(s) * 2
# # # # #
# # # # #
# # # # # def main():
# # # # #     bar('0')
# # # # #
# # # # #
# # # # # main()
# # # #
# # # #
# # # # # 记录错误
# # # # # 通过配置，logging还可以把错误记录到日志文件里，方便事后排查。
# # # # # import logging
# # # # #
# # # # #
# # # # # def foo(s):
# # # # #     return 10 / int(s)
# # # # #
# # # # #
# # # # # def bar(s):
# # # # #     return foo(s) * 2
# # # # #
# # # # #
# # # # # def main():
# # # # #     try:
# # # # #         bar('0')
# # # # #     except Exception as e:
# # # # #         logging.exception(e)
# # # # #
# # # # #
# # # # # main()
# # # # # print('END')
# # # #
# # # #
# # # # # 抛出错误
# # # # # class FooError(ValueError):
# # # # #     pass
# # # # #
# # # # #
# # # # # # 自己定义错误信息
# # # # # def foo(s):
# # # # #     n = int(s)
# # # # #     if n == 0:
# # # # #         raise FooError('invalid value: %s' % s)
# # # # #     return 10 / n
# # # # #
# # # # #
# # # # # foo('0')
# # # #
# # # #
# # # # # 第二种错误处理
# # # # # def foo(s):
# # # # #     n = int(s)
# # # # #     if n == 0:
# # # # #         raise ValueError('2：invalid value: %s' % s)
# # # # #     return 10 / n
# # # # #
# # # # #
# # # # # def bar():
# # # # #     try:
# # # # #         foo('0')
# # # # #     except ValueError as e:
# # # # #         print('2：ValueError')
# # # # #         raise
# # # #
# # # #
# # # # # bar()
# # # #
# # # #
# # # # # raise语句如果不带参数，就会把当前错误原样抛出。
# # # # # 此外，在except中raise一个Error，还可以把一种类型的错误转化成另一种类型：
# # # # # 只要是合理的转换逻辑就可以，
# # # # # 但是，决不应该把一个IOError转换成毫不相干的ValueError。
# # # # # try:
# # # # #     10 / 0
# # # # # except ZeroDivisionError:
# # # # #     raise ValueError('input error!')
# # # #
# # # #
# # # # # from functools import reduce
# # # # #
# # # # #
# # # # # def str2num(s):
# # # # #     return float(s)
# # # # #
# # # # #
# # # # # def calc(exp):
# # # # #     ss = exp.split('+')
# # # # #     ns = map(str2num, ss)
# # # # #     return reduce(lambda acc, x: acc + x, ns)
# # # # #
# # # # #
# # # # # def main():
# # # # #     r = calc('100 + 200 + 345')
# # # # #     print('100 + 200 + 345 =', r)
# # # # #     r = calc('99 + 88 + 7.6')
# # # # #     print('99 + 88 + 7.6 =', r)
# # # # #
# # # # #
# # # # # main()
# # # #
# # # #
# # # # # 调试
# # # # # 断言
# # # # # def foo(s):
# # # # #     n = int(s)
# # # # #     assert n != 0, 'n is zero!'
# # # # #     return 10 / n
# # # # #
# # # # #
# # # # # def main():
# # # # #     foo('0')
# # # #
# # # #
# # # # # main()
# # # #
# # # #
# # # # # 启动Python的-0，可以关闭assert的打印
# # # # # 关闭后，你可以把所有的assert语句当成pass来看。
# # # #
# # # #
# # # # # 使用logging来输出错误信息
# # # # # logging允许指定记录信息的级别，有debug，info，warning，error等几个级别
# # # # # 当我们指定level=INFO时，logging.debug就不起作用了。
# # # # # 同理，指定level=WARNING后，debug和info就不起作用了
# # # # # 这样一来，可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。
# # # # # logging的另一个好处是通过简单的配置，一条语句可以同时输出到不同的地方，
# # # # # 比如console和文件。
# # # # # import logging
# # # # # logging.basicConfig(level=logging.INFO)
# # # # #
# # # # # s = '0'
# # # # # n = int(s)
# # # # # logging.info('n = %d' % n)
# # # # # print(10 / n)
# # # #
# # # #
# # # # # 第四种，需要Python的调试器pdb
# # # #
# # # #
# # # # # 单元测试：用来测试函数是否能够正常使用
# # # # # 编写一个Dict类，这个类的行为和dict一致，但是可以通过属性来访问
# # # # # class Dict(dict):
# # # # #
# # # # #     def __init__(self, **kw):
# # # # #         super().__init__(**kw)
# # # # #
# # # # #     def __getattr__(self, key):
# # # # #         try:
# # # # #             return self[key]
# # # # #         except KeyError:
# # # # #             raise AttributeError(r"'Dict object has no attribute '%s'"
# # # # #                                  % key)
# # # # #
# # # # #     def __setattr__(self, key, value):
# # # # #         self[key] = value
# # # # #
# # # # #
# # # # # d = Dict(a=1, b=2)
# # # # # print(d['a'])
# # # # # print(d.a)
# # # #
# # # #
# # # # # 编写单元测试，我们需要引入Python自带的unittest模块，编写mydict_test.py如下
# # # # import unittest
# # # #
# # # # from mydict import Dict
# # # #
# # # #
# # # # # setUp和tearDown
# # # # # setUp()和tearDown()方法。这两个方法会分别在每调用一个测试方法的前后分别被执行
# # # # # 可以再次运行测试看看每个测试方法调用前后是否会打印出setUp...和tearDown...
# # # # # class TestDict(unittest.TestCase):
# # # # #
# # # # #     def setUp(self):
# # # # #         print('setUp...')
# # # # #
# # # # #     def test_init(self):
# # # # #         d = Dict(a=1, b='test')
# # # # #         self.assertEqual(d.a, 1)
# # # # #         self.assertEqual(d.b, 'test')
# # # # #         self.assertTrue(isinstance(d, dict))
# # # # #         print('1...')
# # # # #
# # # # #     def test_key(self):
# # # # #         d = Dict()
# # # # #         d['key'] = 'value'
# # # # #         self.assertEqual(d.key, 'value')
# # # # #         print('2...')
# # # # #
# # # # #     def test_attr(self):
# # # # #         d = Dict()
# # # # #         d.key = 'value'
# # # # #         self.assertTrue('key' in d)
# # # # #         self.assertEqual(d['key'], 'value')
# # # # #         print('3...')
# # # # #
# # # # #     def test_keyerror(self):
# # # # #         d = Dict()
# # # # #         with self.assertRaises(KeyError):
# # # # #             value = d['empty']
# # # # #         print('4...')
# # # # #
# # # # #     def test_attreror(self):
# # # # #         d = Dict()
# # # # #         with self.assertRaises(AttributeError):
# # # # #             value = d.empty
# # # # #         print('5...')
# # # # #
# # # # #     def tearDown(self):
# # # # #         print('tearDown...')
# # # # #
# # # # #
# # # # # if __name__ == '__main__':
# # # # #     unittest.main()
# # # #
# # # #
# # # # class Student(object):
# # # #     def __init__(self, name, score):
# # # #         self.name = name
# # # #         self.score = score
# # # #
# # # #     def get_grade(self):
# # # #         if 80 <= self.score <= 100:
# # # #             return 'A'
# # # #         elif 60 <= self.score < 80:
# # # #             return 'B'
# # # #         elif self.score < 0 or self.score > 100:
# # # #             raise ValueError
# # # #         return 'C'
# # # #
# # # #
# # # # class TestStudent(unittest.TestCase):
# # # #
# # # #     def test_80_to_100(self):
# # # #         s1 = Student('Bart', 80)
# # # #         s2 = Student('Lisa', 100)
# # # #         self.assertEqual(s1.get_grade(), 'A')
# # # #         self.assertEqual(s2.get_grade(), 'A')
# # # #
# # # #     def test_60_to_80(self):
# # # #         s1 = Student('Bart', 60)
# # # #         s2 = Student('Lisa', 79)
# # # #         self.assertEqual(s1.get_grade(), 'B')
# # # #         self.assertEqual(s2.get_grade(), 'B')
# # # #
# # # #     def test_0_to_60(self):
# # # #         s1 = Student('Bart', 0)
# # # #         s2 = Student('Lisa', 59)
# # # #         self.assertEqual(s1.get_grade(), 'C')
# # # #         self.assertEqual(s2.get_grade(), 'C')
# # # #
# # # #     def test_invalid(self):
# # # #         s1 = Student('Bart', -1)
# # # #         s2 = Student('Lisa', 101)
# # # #         with self.assertRaises(ValueError):
# # # #             s1.get_grade()
# # # #         with self.assertRaises(ValueError):
# # # #             s2.get_grade()
# # # #
# # # #
# # # # if __name__ == '__main__':
# # # #     unittest.main()
# # #
# # # # 文档测试
# # # import re
# # #
# # # m = re.search('(?<=abc)def', 'abcdef')
# # # print(m.group(0))
# # #
# # #
# # # def abs(n):
# # #     """
# # #     Function to get absolute value of number.
# # #
# # #     Example:
# # #
# # #     >>> abs(1)
# # #     1
# # #     >>> abs(-1)
# # #     1
# # #     >>> abs(0)
# # #     0
# # #     """
# # #
# # #     return n if n >= 0 else (-n)
# #
# #
# # # 文件读写
# # # 读文件:
# # # 1.打开文件
# # f = open('/Users/yangxudong/Desktop/HelloPython/mydict.py', 'r')
# # # 2.read()读文件:调用read()方法可以一次读取文件的全部内容，Python把内容读到内存，
# # # 用一个str对象表示
# # # print(f.read())
# # # 3.关闭文件夹：避免占用系统资源，因为同一时间打开的文件夹是有数量限制的
# # f.close()
# #
# # # 使用with语句来正确调用close()方法，保证能关闭文件
# # # with open('/Users/yangxudong/Desktop/HelloPython/mydict.py', 'r') as f:
# # #     print(f.readlines())
# # #     把末尾的'\n'删掉
# # #     for line in f.readlines():
# # #         print(line.strip())
# #
# # # read(size)限制每次读取的大小，readline():每次读取一行内容
# # # readlines()：读取所有内容，并将所有内容按list返回
# #
# # # file-like Object:像open()函数返回的这种有个read()方法的对象，
# # # 在Python中统称为file-like Object
# # # 除了file外，还可以是内存的字节流，网络流，自定义流等等。
# # # file-like Object不要求从特定类继承，只要写个read()方法就行。
# #
# # # 二进制文件
# # # 前面讲的默认都是读取文本文件，并且是UTF-8编码的文本文件。
# # # 要读取二进制文件，比如图片、视频等等，用'rb'模式打开文件即可：
# # f = open('/Users/yangxudong/Desktop/HelloPython/111.png', 'rb')
# # # print(f.read())
# #
# # # 字符编码
# # # 要读取非UTF-8编码的文本文件，需要给open()函数传入encoding参数，例，读取GBK编码的文件
# # # f = open('/Users/yangxudong/Desktop/gbk.text', 'r', encoding='gbk')
# # # print(f.read())
# # # 遇到有些编码不规范的文件，你可能会遇到UnicodeDecodeError，
# # # 因为在文本文件中可能夹杂了一些非法编码的字符。
# # # 遇到这种情况，open()函数还接收一个errors参数，表示如果遇到编码错误后如何处理。
# # # 最简单的方式是直接忽略：
# # # f = open('e', 'r', encoding='gbk', errors='ignore')
# #
# # # 写文件
# # # 写文件首先也要打开文件，在写文件时，传入标识符，'w'或者'wb'表示写文本文件或者二进制文件
# # # f = open('/Users/yangxudong/Desktop/HelloPython/mydict.py', 'w')
# # # f.write('Hello, world')
# # # f.close()
# # # 此方法会自动，在写完之后，会自动调用close()方法
# # # 以'w'模式写入文件时，如果文件已存在，会直接覆盖（相当于删掉后新写入一个文件）。
# # # 如果我们希望追加到文件末尾怎么办？可以传入'a'以追加（append）模式写入。
# # with open('/Users/yangxudong/Desktop/HelloPython/mydict.py', 'a') as f:
# #     f.write('Hello, world! \n')
# #
# # # StringIO和BytesIO
# # # StringIO：在内存中读写str
# # # 要把str写入StringIO，我们需要先创建一个StringIO，然后，像文件一样写入即可
# # from io import StringIO
# #
# # f = StringIO()
# # print(f.write('hello'))
# # print(f.write(' '))
# # print(f.write('world'))
# # # getvalue()方法用于获得写入后的str。
# # print(f.getvalue())
# #
# # # 要读取StringIO，可以用一个str初始化StringIO，然后，像读文件一样读取：
# # from io import StringIO
# #
# # f = StringIO('Hello!\nHi\nGoodBye')
# # while True:
# #     s = f.readline()
# #     if s == '':
# #         break
# #     print(s.strip())
# #
# # # BytesIO:操作二进制数据，使用BytesIO
# # # 我们创建一个BytesIO，然后写入一些bytes
# # from io import BytesIO
# #
# # f = BytesIO()
# # f.write('中文'.encode('utf-8'))
# # print(f.getvalue())
# #
# # # 和StringIO类似，可以用一个bytes初始化BytesIO，然后，像读文件一样读取：
# # from io import BytesIO
# #
# # f = BytesIO(b'\xe4\xb8\xad\xe6\x96\x87')
# # print(f.read())
# #
# # # 操作文件和目录
# # # Python内置的os模块也可以直接调用操作系统提供的接口函数
# # import os
# #
# # print(os.name)
# # # 获取详细的系统信息，可以调用uname()函数：
# # print(os.uname())
# #
# # # 环境变量
# # # 在操作系统中定义的环境变量，全部保存在os.environ这个变量中，可以直接查看
# # print(os.environ)
# # # 获取某个环境变量的值
# # print(os.environ.get("PATH"))
# # print(os.environ.get('x', 'default'))
# #
# # # 操作文件和目录
# # # 查看当前目录的绝对路径
# # print(os.path.abspath('.'))
# # # 在某个目录下创建一个新的项目，首先把新目录的完整路径表示出来
# # print(os.path.join('/Users/yangxudong/Desktop', 'testdir'))
# # # 然后创建一个目录
# # # os.mkdir('/Users/yangxudong/Desktop/testdir')
# # # 删掉一个目录
# # # os.rmdir('/Users/yangxudong/Desktop/testdir')
# # # 把两个路径合成一个
# # # 不要直接拼字符串，而要通过os.path.join()函数，这样可以正确处理不同操作系统的路径分隔符
# # # 在Linux/Unix/Mac下，os.path.join()返回这样的字符串
# # # part-1/part-2
# #
# # # 而Windows下会返回这样的字符串：
# # # part-1\part-2
# #
# # # 同样的道理，要拆分路径时，也不要直接去拆字符串，
# # # 而要通过os.path.split()函数，这样可以把一个路径拆分为两部分，
# # # 后一部分总是最后级别的目录或文件名：
# # print(os.path.split('/Users/yangxudong/Desktop/testdir'))
# # # 获得文件的扩展名
# # # 这些合并、拆分路径的函数并不要求目录和文件要真实存在，它们只对字符串进行操作
# # print(os.path.splitext('/Users/yangxudong/Desktop/testdir/house.png'))
# # # 对文件重命名
# # # 重命名之后，如果不加路径。文件就会更改位置，所以需要加上更改后的路径
# # # os.rename('/Users/yangxudong/Desktop/testdir/222.png',
# # #           '/Users/yangxudong/Desktop/testdir/111.png')
# # # os中不存在复制模块
# # # 幸运的是shutil模块提供了copyfile()的函数
# # # 你还可以在shutil模块中找到很多实用函数，它们可以看做是os模块的补充
# # print([x for x in os.listdir('.') if os.path.isdir(x)])
# # # 列出所有的.py文件
# # print(x for x in os.listdir('.') if os.path.isfile(x) and
# #       os.path.splitext(x)[1] == '.py')
# #
# # # import os
# # # import os.path as op
# # #
# # # inp = input('请输入字符串，我将为你查找是否有包含字符串的文件:')
# # #
# # #
# # # def get_files(inp, n_dir='.'):
# # #     x = os.listdir(n_dir)
# # #     if x == False:
# # #         pass
# # #     for fi in x:
# # #         if op.isdir(fi):
# # #             get_files(inp, fi)
# # #         else:
# # #             file = op.split(fi)
# # #             if inp in file[1]:
# # #                 print(file[1])
# # #
# # #
# # # get_files(inp)
# #
# #
# # # import os
# # #
# # # s = input('Input the string you want find:')
# # # ls = []
# # # for x in os.listdir('.'):
# # #     if s in x:
# # #         ls.append(x)
# # #         print(x, "\n")
# # #     if os.path.isdir(x):
# # #         for y in os.listdir('./' + x):
# # #             if s in y:
# # #                 ls.append('./' + y)
# # #                 print('./' + y + "\n")
# # # print(ls)
# #
# # # 序列化
# # # 在程序运行过程中，所有的变量都是在内存中，比如，定义一个dict
# # # 可以随时修改变量，比如把name改成'Bill'，
# # # 但是一旦程序结束，变量所占用的内存就被操作系统全部回收。
# # # 如果没有把修改后的'Bill'存储到磁盘上，下次重新运行程序，变量又被初始化为'Bob'
# # # d = dict(name='Bob', age=20, socre=88)
# #
# # # 我们把变量从内存中变成可存储或传输的过程称之为序列化，
# # # 在Python中叫pickling，
# # # 在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思
# # # 序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。
# # # 反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling
# # # Python提供了pickle模块来实现序列化
# # import pickle
# #
# # # 把一个对象序列化并写入文件
# # d = dict(name='Bob', age=20, score=88)
# # print(pickle.dumps(d))
# #
# # # pickle.dumps()方法把任意对象序列化成一个bytes，
# # # 然后，就可以把这个bytes写入文件。
# # # 或者用另一个方法pickle.dump()直接把对象序列化后写入一个file-like Object
# # # f = open('dump.text', 'wb')
# # # pickle.dump(d, f)
# # # f.close()
# # # print(d)
# #
# # # Python转变为json数据
# # import json
# #
# # d = dict(name='Bob', age=20, score=88)
# # # print(json.dumps(d))
# #
# # # dumps()方法返回一个str，内容就是标准的json
# # # 类似的，dump()方法可以直接把JSON写入一个file-like Object
# #
# # # 要把JSON反序列化为Python对象，用loads()或者对应的load()方法，
# # # 前者把JSON的字符串反序列化，后者从file-like Object中读取字符串并反序列化
# # # 由于JSON标准规定JSON编码是UTF-8，
# # # 所以我们总是能正确地在Python的str与JSON的字符串之间转换。
# # json_str = '{"age": 20, "score": 88, "name": "Bob"}'
# # # print(json.loads(json_str))
# #
# # # Python的dict对象可以直接序列化为JSON的{}，
# # # 不过，很多时候，我们更喜欢用class表示对象，比如定义Student类，然后序列化：
# # import json
# #
# #
# # class Student(object):
# #
# #     def __init__(self, name, age, score):
# #         self.name = name
# #         self.age = age
# #         self.score = score
# #
# #
# # # 此处无法直接将class转化为json
# # s = Student('Bob', 20, 88)
# #
# #
# # # print(json.dumps(s))
# #
# # # 可选参数default就是把任意一个对象变成一个可序列为JSON的对象，
# # # 我们只需要为Student专门写一个转换函数，再把函数传进去即可
# # def student2dict(std):
# #     return {
# #         'name': std.name,
# #         'age': std.age,
# #         'score': std.score
# #     }
# #
# #
# # # Student实例首先被student2dict()函数转换成dict，然后再被顺利序列化为JSON
# # print(json.dumps(s, default=student2dict))
# # # 不过，下次如果遇到一个Teacher类的实例，照样无法序列化为JSON。
# # # 我们可以偷个懒，把任意class的实例变为dict：
# # # 通常class的实例都有一个__dict__属性，实际上就是一个dict，用来存储少量数据
# # # 也有少数列外，例如定义了__slots__属性的class
# # print(json.dumps(s, default=lambda obj: obj.__dict__))
# #
# #
# # # 同样的道理，如果我们要把JSON反序列化为一个Student对象实例，
# # # loads()方法首先转换出一个dict对象，
# # # 然后，我们传入的object_hook函数负责把dict转换为Student实例
# # def dict2student(d):
# #     return Student(d['name'], d['age'], d['score'])
# #
# #
# # json_str = '{"age": 20, "score": 88, "name": "Bob"}'
# # # 打印出的是反序列化的Student实例对象
# # print(json.loads(json_str, object_hook=dict2student))
# #
# #
# # obj = dict(name='小明', age=20)
# # s = json.dumps(obj, ensure_ascii=True)
# # print(s)
#
# # import os
#
# # print('Process (%s) start...' % os.getpid())
#
# # 多进程：getppid()得到父进程的id, 子进程永远返回0. fork()用来开辟子进程
#
# # pid = os.fork()
# #
# # if pid == 0:
# #     print('I am child process (%s) and my parent is %s.' % (os.getpid(),
# #                                                             os.getppid()))
# # else:
# #     print('I (%s) just create a child process (%s).' % (os.getpid(), pid))
# #
# #
# # # multiprocessing：跨平台版本的多进程模块
# # from multiprocessing import Process
# # import os
# #
# #
# # # 子进程执行的代码
# # def run_proc(name):
# #     print('Run child process %s (%s)...' % (name, os.getpid()))
# #
# #
# # if __name__ == '__main__':
# #     print('Parent process %s.' % os.getpid())
# #     p = Process(target=run_proc, args=('test',))
# #     print('Child process will start.')
# #     p.start()
# #     p.join()
# #     print('Child process end.')
#
#
# # Pool：进程池，批量创建子进程
# # from multiprocessing import Pool
# # import os, time, random
# #
# #
# # def long_time_task(name):
# #     print('Run task %s (%s)...' % (name, os.getpid()))
# #     start = time.time()
# #     time.sleep(random.random() * 3)
# #     end = time.time()
# #     print('Task %s runs %0.2f seconds.' % (name, (end - start)))
# #
# #
# # if __name__ == '__main__':
# #     print('Parent process %s.' % os.getpid())
# #     p = Pool(4)
# #     for i in range(5):
# #         p.apply_async(long_time_task, args=(i,))
# #     print('Waiting for all subprocesses done...')
# #     p.close()
# #     p.join()
# #     print('All subprocesses done.')
#
# # 子进程：很多时候并不是自身，而是一个外部进程。创建了子进程后，还要控制输入和输出
# # subprocess：这个模块可以让我们非常方便的启动一个子进程，然后控制输入和输出
# # 下面的例子演示了如何在Python代码中运行命令nslookup www.python.org，
# # 这和命令行直接运行的效果是一样的：
# # import subprocess
# #
# # print('$ nslookup www.python.org')
# # r = subprocess.call(['nslookup', 'www.python.org'])
# # print('Exit code:', r)
#
# # 如果子进程还需要输入，则可以通过communicate()方法输入：
# # import subprocess
# #
# # print('$ nslookup')
# # p = subprocess.Popen(['nslookup'], stdin=subprocess.PIPE,
# #                      stdout=subprocess.PIPE, stderr=subprocess.PIPE)
# # output, err = p.communicate(b'set q=mx\npython.org\nexit\n')
# # print(output.decode('utf-8'))
# # print('Exit code:', p.returncode)
#
# # 上边的代码相当于在命令行执行命令nslookup，然后手动输入
# # set q=mx
# # python.org
# # exit
#
# # 进程间的通信
# # Process之间肯定是需要通信的，操作系统提供了很多机制来实现进程间的通信。
# # Python的multiprocessing模块包装了底层的机制，提供了Queue、Pipes等多种方式来交换数据。
# # from multiprocessing import Process, Queue
# # import os, time, random
# #
# #
# # # 写数据进程执行的代码
# # # getpid返回当前进程标识，getppid返回父进程标识。
# # def write(q):
# #     print('Process to write: %s' % os.getpid())
# #     for value in ['A', 'B', 'C']:
# #         print('Put %s to queue...' % value)
# #         q.put(value)
# #         time.sleep(random.random())
# #
# #
# # # 读取数据进程执行的代码
# # def read(q):
# #     print('Process to read: %s' % os.getpid())
# #     while True:
# #         value = q.get(True)
# #         print('Get %s from queue.' % value)
# #
# #
# # if __name__ == '__main__':
# #     # 父进程创建Queue，并传给各个子进程
# #     q = Queue()
# #     pw = Process(target=write, args=(q,))
# #     pr = Process(target=read, args=(q,))
# #     # 启动子进程pw，写入：
# #     pw.start()
# #     # 启动子进程，读取：
# #     pr.start()
# #     # 等待pw结束
# #     pw.join()
# #     # pr进程里是死循环，无法等待其结束，只能强行终止
# #     pr.terminate()
# # 多任务可以由多进程完成，也可以由一个进程内的多线程完成
# # Python的标准库提供了两个模块：_thread和threading，
# # _thread是低级模块，threading是高级模块，对_thread进行了封装。
# # 绝大多数情况下，我们只需要使用threading这个高级模块
#
# # 启动一个线程就是把一个函数传入并创建Thread实例，然后调用start()开始执行
# # 由于任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程，
# # Python的threading模块有个current_thread()函数，它永远返回当前线程的实例。
# # 主线程实例的名字叫MainThread，子线程的名字在创建时指定，我们用LoopThread命名子线程。
# # 名字仅仅在打印时用来显示，完全没有其他意义，
# # 如果不起名字Python就自动给线程命名为Thread-1，Thread-2……
# # import time, threading
# #
# #
# # def loop():
# #     print('thread %s is running...' % threading.current_thread().name)
# #     n = 0
# #     while n < 5:
# #         n = n + 1
# #         print('thread %s >>> %s' % (threading.current_thread().name, n))
# #         time.sleep(1)
# #     print('thread %s ended.' % threading.current_thread().name)
# #
# #
# # print('thread %s is running...' % threading.current_thread().name)
# # t = threading.Thread(target=loop, name='LoopThread')
# # t.start()
# # t.join()
# # print('thread %s ended.' % threading.current_thread().name)
#
# # 多线程之间最大的问题在于，多个线程同时操作一个变量，造成内容混乱
# # 当t1、t2交替执行时，只要循环次数足够多，balance的结果就不一定是0了
# # import time, threading
#
# # balance = 0
#
#
# # def change_it(n):
# #     # 先存后取，结果应该为0
# #     global balance
# #     balance = balance + n
# #     balance = balance - n
# #
# #
# # def run_thread(n):
# #     for i in range(100000):
# #         change_it(n)
# #
# #
# # t1 = threading.Thread(target=run_thread, args=(5,))
# # t2 = threading.Thread(target=run_thread, args=(5,))
# # t1.start()
# # t2.start()
# # t1.join()
# # t2.join()
# # print('no lock %s' % balance)
#
#
# # 在一个线程修改balance时，别的线程不能对balance修改
# # 对线程进行加锁：同一时刻最多只有一个线程持有锁
#
# # balance = 0
# # lock = threading.Lock()
# #
# #
# # def run_thread(n):
# #     for i in range(100000):
# #         # 先要获取锁
# #         lock.acquire()
# #         try:
# #             # 修改
# #             change_it(n)
# #         finally:
# #             # 修改完成之后，释放锁🔐
# #             lock.release()
#
#
# # 当多个线程同时执行lock.acquire()时，只有一个线程能成功的获取锁
# # 然后继续执行代码，其他线程持续等待，直到获取锁为止
# # 我们用try...finally来确保锁一定会被释放
#
#
# # ThreadLocal
# # 在多线程环境下，每个线程都有自己的数据。
# # 一个线程使用自己的局部变量比使用全局变量好，
# # 因为局部变量只有线程自己能看见，不会影响其他线程，而全局变量的修改必须加锁。
# # 使用局部变量的问题，在函数调用的时候，传递起来很麻烦
#
# # class Student(object):
# #
# #     def __init__(self, name, score):
# #         self.name = name
# #         self.score = score
# #
# #     pass
#
#
# # def process_student(name):
# #     # std是局部变量，但是每个函数都要用它，因此必须传进去：
# #     std = Student(name)
# #     do_task_1(std)
# #     do_task_2(std)
# #
# #
# # def do_task_1(std):
# #     do_subtask_1(std)
# #     do_subtsak_2(std)
# #
# #
# # def do_task_2(std):
# #     do_subtask_2(std)
# #     do_subtask_2(std)
#
# # 创建全局Threading对象
# # ThreadLocal最常用的地方就是为每个线程绑定一个数据库连接，
# # HTTP请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。
# # import threading
# #
# # local_school = threading.local()
# #
# #
# # def process_student():
# #     # 获取当前线程关联的student
# #     std = local_school.student
# #     print('Hello, %s (in %s)' % (std, threading.current_thread().name))
# #
# #
# # def process_thread(name):
# #     # 绑定ThreadLocal的student
# #     local_school.student = name
# #     process_student()
# #
# #
# # t1 = threading.Thread(target=process_thread, args=('Alice',),
# #                       name='Thread-A')
# # t2 = threading.Thread(target=process_thread, args=('Bob',),
# #                       name='Thread-B')
# # t1.start()
# # t2.start()
# # t1.join()
# # t2.join()
#
# # 一个ThreadLocal变量虽然是全局变量，但每个线程都只能读写自己线程的独立副本，互不干扰。
# # ThreadLocal解决了参数在一个线程中各个函数之间互相传递的问题
#
# # 对于计算密集型任务，最好用C语言编写
#
# # 如果充分利用操作系统提供的异步IO支持，就可以用单进程单线程模型来执行多任务，
# # 这种全新的模型称为事件驱动模型
#
# # 对应到Python语言，单线程的异步编程模型称为协程，
# # 有了协程的支持，就可以基于事件驱动编写高效的多任务程序。我们会在后面讨论如何编写协程。
#
# # 分布式进程
# # 在Thread和Process中，应当优选Process，因为Process更稳定，
# # 而且，Process可以分布到多台机器上，而Thread最多只能分布到同一台机器的多个CPU上
#
# # 如果我们已经有一个通过Queue通信的多进程程序在同一台机器上运行，
# # 现在，由于处理任务的进程任务繁重，希望把发送任务的进程和处理任务的进程分布到两台机器上。
# # 怎么用分布式进程实现？
#
# # 原有的Queue可以继续使用，但是，通过managers模块把Queue通过网络暴露出去，
# # 就可以让其他机器的进程访问Queue了。
#
#
# # print('')
# # # 判断一个字符串是否是一个合法的Email
# # # 用\d可以匹配一个数字，\w可以匹配一个字母或数字
# #
# # # [0-9a-zA-Z\_]可以匹配一个数字、字母或者下划线；
# #
# # # [0-9a-zA-Z\_]+可以匹配至少由一个数字、字母或者下划线组成的字符串，
# # # 比如'a100'，'0_Z'，'Py3000'等等
# #
# # # [a-zA-Z\_][0-9a-zA-Z\_]*可以匹配由字母或下划线开头，
# # # 后接任意个由一个数字、字母或者下划线组成的字符串，也就是Python合法的变量
# #
# # # [a-zA-Z\_][0-9a-zA-Z\_]{0, 19}
# # # 更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）
# #
# # # A|B可以匹配A或B，所以(P|p)ython可以匹配'Python'或者'python'
# #
# # # ^表示行的开头，^\d表示必须以数字开头
# #
# # # $表示行的结束，\d$表示必须以数字结束
# #
# # # py也可以匹配'python'，但是加上^py$就变成了整行匹配，就只能匹配'py'了
# #
# #
# # # re模块
# # import re
# #
# # print('ABC\-001')
# # print(r'ABC\-001')
# #
# # # 切割字符串
# # st = "a b   c".split(' ')
# # print(st)
# #
# # st1 = re.split(r'\s+', 'a b   c')
# # print(st1)
# #
# # # 分割空格加逗号
# # st3 = re.split(r'[\s\,]+', 'a,b, c ,   d')
# # print(st3)
# #
# # # 分割空格加逗号分号
# # st4 = re.split(r'[\s\,\;]+', 'a, b;; c   , ;  d')
# # print(st4)
# #
# # # 分组
# # # 除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。
# # # 用()表示的就是要提取的分组（Group）
# # # ^(\d{3})-(\d{3,8})$分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码
# # m = re.match(r'^(\d{3})-(\d{3,8})$', '010-12345')
# #
# # # 如果正则表达式中定义了组，就可以在Match对象上用group()方法提取出子串来
# # # 注意到group(0)永远是原始字符串，group(1)、group(2)……表示第1、2、……个子串。
# # print(m)
# # print(m.group(0))
# # print(m.group(1))
# #
# # # tt = '19:05:30'
# # # m = re.match(r'^(0[0-9]|1[0-9]|2[0-3]|[0-9])')
# #
# #
# # # 贪婪匹配
# # # 正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符
# #
# # print(re.match(r'^(\d+)(0*)$', '102300').groups())
# # # 由于\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了
# # # 必须让\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，
# # # 加个?就可以让\d+采用非贪婪匹配
# # print(re.match(r'^(\d+?)(0*)$', '102300').groups())
# #
# # # 编译
# # # 当我们在Python中使用正则表达式时，re模块内部会干两件事情
# # # 1.编译正则表达式，如果正则表达式的字符串本身不合法，会报错；
# # # 2.用编译后的正则表达式去匹配字符串。
# # # 如果一个正则表达式要重复使用几千次，出于效率的考虑，
# # # 我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配：
# # import re
# # # 编译
# # re_telephone = re.compile(r'^(\d{3})-(\d{3,8})$')
# # # 使用
# # print(re_telephone.match('010-12345').groups())
# # print(re_telephone.match('010-8086').groups())
# #
# #
# # # 验证是否为正确的邮箱
# # def is_valid_email(addresss):
# #     if re.match(r'^[a-z]+(.[a-z]+)*@[a-z]+(.[a-z]+)+$', addresss):
# #         return '匹配成功'
# #     else:
# #         return '匹配失败'
# #
# #
# # print(is_valid_email("someone@gmail.com"))
# # print(is_valid_email('bill.gates@microsoft.com'))
# # print(is_valid_email('bob#example.com'))
# # print(is_valid_email('mr-bob@example.com'))
#
# # datetime
# # 获取当前日期和时间
# # 注意到datetime是模块，datetime模块还包含一个datetime类，
# # 通过from datetime import datetime导入的才是datetime这个类。
# # 如果仅导入import datetime，则必须引用全名datetime.datetime
# # datetime.now()返回当前日期和时间，其类型是datetime
# # from datetime import datetime
# # now = datetime.now()
# # print(now)
# # print(type(now))
#
# # 获取指定日期和时间
# # dt = datetime(2015, 4, 19, 12, 20)
# # print(dt)
#
# # datetime转换为timestamp
# # 在计算机中，时间实际上是用数字表示的。
# # 我们把1970年1月1日 00:00:00 UTC+00:00时区的时刻称为epoch time，记为0
# # （1970年以前的时间timestamp为负数），当前时间就是相对于epoch time的秒数，
# # 称为timestamp。
# # 转换时间
#
# # from datetime import datetime, timedelta, timezone
# # from collections import namedtuple, deque, defaultdict, OrderedDict, \
# #     Counter
# #
# # dt = datetime(2018, 1, 1, 1, 1)
# # # timestamp：在较低的Python版本中没有此方法
# # # print(dt.timestamp())
# # # 注意Python的timestamp是一个浮点数。如果有小数位，小数位表示毫秒数。
# #
# # # timestamp转换为datetime
# # # 要把timestamp转换为datetime，使用datetime提供的fromtimestamp()方法：
# # # from datetime import datetime
# # # 注意到timestamp是一个浮点数，它没有时区的概念，而datetime是有时区的。
# # # 上述转换是在timestamp和本地时间做转换
# # t = 1429417200.0
# # # print(datetime.fromtimestamp(t))
# #
# # # timestamp也可以直接被转换到UTC标准时区的时间：
# # t = 1429417200.0
# # # 转化为本地时间
# # # print(datetime.fromtimestamp(t))
# # # 转化为UTC时间
# # # print(datetime.utcfromtimestamp(t))
# #
# # # str转化为datetime
# # cady = datetime.strptime('2015-6-1 18:19:59', '%Y-%m-%d %H:%M:%S')
# # # print(cady)
# #
# # # datetime转化为str
# # now = datetime.now()
# # # print(now.strftime('%a, %b %d %H:%M'))
# #
# # # datetime加减
# # now = datetime.now()
# # # print(now)
# # # datetime.datetime(2018, 7, 2, 15, 36, 43)
# # # print(now + timedelta(hours=10))
# # # print(now - timedelta(days=1))
# # i = 0
# # while i < 10:
# #     i = i + 1
# #     # print(now - timedelta(weeks=i) - timedelta(days=i))
# # # print(now - timedelta(weeks=1) - timedelta(days=1))
# #
# # # 本地时间转化为UTC时间
# # # 创建时区UTC+8:00
# # tz_utc_8 = timezone(timedelta(hours=8))
# # now = datetime.now()
# # # 强制设置为UTC+8:00
# # dt = now.replace(tzinfo=tz_utc_8)
# # print(dt)
# #
# # # 时区转换
# # # 拿到UTC时间，并强制设置时区为UTC+8:00
# # utc_dt = datetime.utcnow().replace(tzinfo=timezone.utc)
# # print(utc_dt)
# # # astimezone()将时区转化为北京时间
# # bj_dt = utc_dt.astimezone(timezone(timedelta(hours=8)))
# # print(bj_dt)
# # # 将时间转化为东京时间
# # tokoy_dt = utc_dt.astimezone(timezone(timedelta(hours=9)))
# # print(tokoy_dt)
# #
# # # collection:集合模块
# # # namedtuple：定义一个坐标
# # # 引入的表头在上边（使用哪个模块，一定要引入）
# # Point = namedtuple('Point', ['x', 'y'])
# # # namedtuple是一个函数，它用来创建一个自定义的tuple对象，并且规定了tuple元素的个数，
# # # 并可以用属性而不是索引来引用tuple的某个元素。
# # p = Point(1, 2)
# # print('x: %s' % p.x)
# # print('y: %s' % p.y)
# # # 同样的namedtuple也可以定义三个元素
# # Circle = namedtuple('Circle', ['x', 'y', 'r'])
# # cir = Circle(1, 2, 3)
# #
# # # deque: 是为了高效实现插入和删除操作的双向列表，适合用于队列和栈
# # q = deque(['a', 'b', 'c'])
# # q.append('x')
# # q.appendleft('y')
# # print(q)
# #
# # # defaultdict: 使用dict时，如果引用的Key不存在，就会抛出KeyError。
# # # 如果希望key不存在时，返回一个默认值，就可以用defaultdict
# # # 注意默认值是调用函数返回的，而函数在创建defaultdict对象时传入。
# # # 除了在Key不存在时返回默认值，defaultdict的其他行为跟dict是完全一样的
# # dd = defaultdict(lambda: 'N/A')
# # dd['key1'] = 'abc'
# # print(dd['key1'])
# # print(dd['key'])
# #
# # # OrderedDict：保持Key的顺序，可以用OrderedDict
# # d = dict([('a', 1), ('c', 3), ('b', 2)])
# # print(d)
# # # 排序
# # # 注意，OrderedDict的Key会按照插入的顺序排列，不是Key本身排序
# # od = OrderedDict([('a', 1), ('c', 3), ('b', 2)])
# # print(od)
# #
# #
# # # OrderedDict可以实现一个FIFO（先进先出）的dict，当容量超出限制时，先删除最早添加的Key
# # class LastUpdatedOrderedDict(OrderedDict):
# #
# #     def __init__(self, capacity):
# #         super(LastUpdatedOrderedDict, self).__init__()
# #         self._capacity = capacity
# #
# #     def __setitem__(self, key, value):
# #         containsKey = 1 if key in self else 0
# #         if len(self) - containsKey >= self._capacity:
# #             last = self.popitem(last=False)
# #             print('remove:', last)
# #         if containsKey:
# #             del self[key]
# #             print('set:', (key, value))
# #         else:
# #             print('add:', (key, value))
# #         OrderedDict.__setitem__(self, key, value)
# #
# #
# # # counter: 简单的计数器
# # # 统计字符出现的个数
# # c = Counter()
# # for ch in "programming":
# #     c[ch] = c[ch] + 1
# #
# # print(c)
# #
# # # base64
# # # Base64是一种用64个字符来表示任意二进制数据的方法。
# # # Python内置的base64可以直接进行base64的编解码：
# # import base64
# #
# # print(base64.b64encode(b'binary\x00string'))
# # print(base64.b64decode(b'YmluYXJ5AHN0cmluZw=='))
# # # 由于标准的Base64编码后可能出现字符+和/，在URL中就不能直接作为参数，
# # # 所以又有一种"url safe"的base64编码，其实就是把字符+和/分别变成-和_：
# # print(base64.b64encode(b'i\xb7\x1d\xfb\xef\xff'))
# # print(base64.urlsafe_b64encode(b'i\xb7\x1d\xfb\xef\xff'))
# # print(base64.urlsafe_b64decode(b'abcd--__'))
# #
# #
# # # Base64是一种通过查表的编码方法，不能用于加密，即使使用自定义的编码表也不行
# # # Base64适用于小段内容的编码，比如数字证书签名、Cookie的内容等
# # # 由于=字符也可能出现在Base64编码中，但=用在URL、Cookie里面会造成歧义，
# # # 所以，很多Base64编码后会把=去掉
# #
# # # 标准Base64:
# # tt = base64.urlsafe_b64decode('YWJjZA==')
# # print('22: %s' % tt)
# # # 自动去掉=:
# # print(base64.urlsafe_b64encode(b'abcd'))
# #
# # # Base64是一种任意二进制到文本字符串的编码方法，
# # # 常用于在URL、Cookie、网页中传输少量二进制数据
# #
# # # 请写一个能处理去掉=的base64解码函数：
# # def safe_base64_decode(s):
# #     try:
# #         isinstance(s, str)
# #         if len(s) % 4:
# #             s += b'=' * (4 - (len(s) % 4))
# #         return base64.urlsafe_b64decode(s)
# #     except Exception as e:
# #         raise Exception
# #
# #
# # assert b'abcd' == safe_base64_decode(b'YWJjZA=='), \
# #     safe_base64_decode('YWJjZA==')
# # assert b'abcd' == safe_base64_decode(b'YWJjZA'), \
# #     safe_base64_decode('YWJjZA')
# # print('ok')
#
#
# # struct: struct模块来解决bytes和其他二进制数据类型的转换。
# # import struct
# # >表示字节顺序是big-endian，也就是网络序，I表示4字节无符号整数
# # print(struct.pack('>I', 10240099))
#
# # hashlib：摘要算法。摘要算法又称哈希算法、散列算法。
# # 它通过一个函数，把任意长度的数据转换为一个长度固定的数据串（通常用16进制的字符串表示）
# # import hashlib, random
# #
# # md5 = hashlib.md5()
# # md5.update('how to use md5 in python hashlib?'.encode('utf-8'))
# # # print(md5.hexdigest())
# # # 如果数据量很大，可以分块多次调用update()，最后计算的结果是一样的：
# # md5 = hashlib.md5()
# # md5.update('how to use md5 in '.encode('utf-8'))
# # md5.update('python hashlib?'.encode('utf-8'))
# # # print(md5.hexdigest())
# # # MD5是最常见的摘要算法，速度很快，生成结果是固定的128 bit字节，
# # # 通常用一个32位的16进制字符串表示
# #
# # # 另一种常见的摘要算法是SHA1，调用SHA1和调用MD5完全类似：
# # # SHA1的结果是160 bit字节，通常用一个40位的16进制字符串表示
# # sha1 = hashlib.sha1()
# # sha1.update('how to use sha1 in '.encode('utf-8'))
# # sha1.update('python hashlib?'.encode('utf-8'))
# # # print(sha1.hexdigest())
# #
# # # 比SHA1更安全的算法是SHA256和SHA512，不过越安全的算法不仅越慢，而且摘要长度更长
# # # 由于常用口令的MD5值很容易被计算出来，
# # # 所以，要确保存储的用户口令不是那些已经被计算出来的常用口令的MD5，
# # # 这一方法通过对原始口令加一个复杂字符串来实现，俗称“加盐”
# # # 经过Salt处理的MD5口令，只要Salt不被黑客知道，
# # # 即使用户输入简单口令，也很难通过MD5反推明文口令
# # # def calc_md5(password):
# # #     return get_md5(password + 'the-Salt')
# #
# #
# # # 获取加密的md5字串
# # def get_md5(s):
# #     return hashlib.md5(s.encode('utf-8')).hexdigest()
# #
# #
# # # 加密密码
# # class User(object):
# #     def __init__(self, username, password):
# #         self.username = username
# #         # 循环产生20个字符，加盐字串
# #         self.salt = ''.join([chr(random.randint(48, 122))
# #                              for i in range(20)])
# #         self.password = get_md5(password + self.salt)
# #
# #
# # db = {
# #     'michael': User('michael', '123456'),
# #     'bob': User('bob', 'abc999'),
# #     'alice': User('alice', 'alice2008')
# # }
# #
# #
# # def login(username, password):
# #     if username in db:
# #         # b[username]：根据key值取到Value，字典中的Value是class，User创建的一个实例
# #         # db[username].password：实例的属性包括，username、password和salt
# #         return True if db[username].password == \
# #                        get_md5(password + db[username].salt) else False
# #     else:
# #         return False
# #
# #
# # # 测试:
# # assert login('michael', '123456')
# # assert login('bob', 'abc999')
# # assert login('alice', 'alice2008')
# # assert not login('michael', '1234567')
# # assert not login('bob', '123456')
# # assert not login('alice', 'Alice2008')
# # print('ok')
# #
# #
# # # Hmac算法：Keyed-Hashing for Message Authentication。
# # # 和我们自定义的加salt算法不同，Hmac算法针对所有哈希算法都通用，
# # # 无论是MD5还是SHA-1。采用Hmac替代我们自己的salt算法，可以使程序算法更标准化，也更安全。
# # # 它通过一个标准算法，在计算哈希的过程中，把key混入计算过程中。
# # # 我们首先需要准备待计算的原始消息message，随机key，哈希算法，
# # # 这里采用MD5，使用hmac的代码如下
# # import hmac, random
# # message = b'Hello, world!'
# # key = b'secret'
# # h = hmac.new(key, message, digestmod='MD5')
# # print(h.hexdigest())
# #
# #
# # def hmac_md5(key, s):
# #     return hmac.new(key.encode('utf-8'),
# #                     s.encode('utf-8'), 'MD5').hexdigest()
# #
# #
# # class User(object):
# #     def __init__(self, username, password):
# #         self.username = username
# #         self.key = ''.join([chr(random.randint(48, 122))
# #                             for i in range(20)])
# #         self.password = hmac_md5(self.key, password)
# #
# #
# # db = {
# #     'michael': User('michael', '123456'),
# #     'bob': User('bob', 'abc999'),
# #     'alice': User('alice', 'alice2008')
# # }
#
#
# # itertools: 用于操作迭代对象的函数
# import itertools
#
# # count() 接收两个参数，第一个参数指定开始值，默认为 0，第二个参数指定步长，默认为 1
# # natuals = itertools.count(1)
# # for n in natuals:
# #     print(n)
#
# # repeat()负责把一个元素无限重复下去，不过如果提供第二个参数就可以限定重复次数
# ns = itertools.repeat('A', 3)
# for n in ns:
#     print(n)
#
# # 无限序列只有在for迭代时才会无限地迭代下去，如果只是创建了一个迭代对象，
# # 它不会事先把无限个元素生成出来，事实上也不可能在内存中创建无限多个元素。
# # 无限序列虽然可以无限迭代下去，
# # 但是通常我们会通过takewhile()等函数根据条件判断来截取出一个有限的序列：
# natuals = itertools.count(1)
# ns = itertools.takewhile(lambda x: x <= 10, natuals)
# print(list(ns))
#
# # chain()可以把一组迭代对象串联起来，形成一个更大的迭代器：
# for c in itertools.chain('ABC', 'XYZ'):
#     print(c)
#
# # groupby()把迭代器中相邻的重复元素挑出来放在一起：
# # for key, group in itertools.groupby('AAABBBCCCAA'):
# # print(key, list(group))
#
# # 实际上挑选规则是通过函数完成的，只要作用于函数的两个元素返回的值相等，
# # 这两个元素就被认为是在一组的，而函数返回值作为组的key。
# # 如果我们要忽略大小写分组，就可以让元素'A'和'a'都返回相同的key
# for key, group in itertools.groupby('AaaBBBcAAa', lambda c: c.upper()):
#     print(key, list(group))
#
#
# # 计算pi的值
# def pi(N):
#     # step 1: 创建一个奇数序列: 1, 3, 5, 7, 9, ...
#     # itertools.count(start=0, step=1)
#     # 创建一个无限的迭代器，从start开始，步长为step。
#     odd = itertools.count(1, 2)
#     # step 2: 取该序列的前N项: 1, 3, 5, 7, 9, ..., 2*N-1.
#     oddn = itertools.takewhile(lambda x: x <= 2 * N, odd)
#     # step 3: 添加正负符号并用4除: 4/1, -4/3, 4/5, -4/7, 4/9, ...
#     # step 4: 求和:
#     # **：幂 - 返回x的y次幂，
#     # 假设a=10,b=20，a**b 为10的20次方。
#     # 首先计算(-1)的正负
#     a = 0
#     for x in oddn:
#         a += 4 * (-1) ** ((x - 1) / 2) / x
#     return a
#
#
# # 测试
# print(pi(10))
# print(pi(100))
# print(pi(1000))
# print(pi(10000))
# assert 3.04 < pi(10) < 3.05
# assert 3.13 < pi(100) < 3.14
# assert 3.140 < pi(1000) < 3.141
# assert 3.1414 < pi(10000) < 3.1415
# print('ok')
#
# # contextlib: 针对文件的读写情况，读取之后，必须要关闭文件
# # @contextmanager：在某段代码执行前后自动执行特定代码
# from contextlib import contextmanager
#
#
# # 代码的执行顺序是：
# # with语句首先执行yield之前的语句，因此打印出<h1>；
# # yield调用会执行with语句内部的所有语句，因此打印出hello和world；
# # 最后执行yield之后的语句，打印出</h1>。
# @contextmanager
# def tag(name):
#     print('<%s>' % name)
#     yield
#     print('</%s>' % name)
#
#
# with tag('hi'):
#     print('hello')
#     print('world')
#
# # @closing:如果一个对象没有实现上下文，我们就不能把它用于with语句。
# # 这个时候，可以用closing()来把该对象变为上下文对象
# # 例如，用with语句使用urlopen()
# from contextlib import closing
# from urllib.request import urlopen
#
# with closing(urlopen('https://www.python.org')) as page:
#     for line in page:
#         print(line)
#
#
# # closing也是一个经过@contextmanager装饰的generator，
# # 这个generator编写起来其实非常简单：
# # 它的作用就是把任意对象变为上下文对象，并支持with语句
# @contextmanager
# def closing(thing):
#     try:
#         yield thing
#     finally:
#         thing.close()

# print()
# urllib: 提供了一系列用于操作URL的功能
# Get: urllib的request模块可以非常方便地抓取URL内容，
# 也就是发送一个GET请求到指定的页面，然后返回HTTP的响应：
# 引入ssl模块，解决ssl验证问题
# from urllib import request
# import ssl
#
# ssl._create_default_https_context = ssl._create_unverified_context

# with request.urlopen('https://api.douban.com/v2/book/2129650') as f:
#     data = f.read()
#     print('Status:', f.status, f.reason)
#     for k, v in f.getheaders():
#         print('%s: %s' % (k, v))
#     print('Data:', data.decode('utf-8'))


# 如果我们要想模拟浏览器发送GET请求，就需要使用Request对象，
# 通过往Request对象添加HTTP头，我们就可以把请求伪装成浏览器。
# 例如，模拟iPhone 6去请求豆瓣首页
# 这样豆瓣会返回适合iPhone的移动版网页：
# from urllib import request
# req = request.Request('http://www.douban.com/')
# req.add_header('User-Agent', 'Mozilla/6.0 '
#                              '(iPhone; CPU iPhone OS 8_0 like Mac OS X)'
#                              ' AppleWebKit/536.26 (KHTML, like Gecko)'
#                              ' Version/8.0 Mobile/10A5376e Safari/8536.25')
# with request.urlopen(req) as f:
#     print('Status:', f.status, f.reason)
#     for k, v in f.getheaders():
#         print('%s: %s' % (k, v))
#     print('Data:', f.read().decode('utf-8'))

# post请求
# 如果要以POST发送一个请求，只需要把参数data以bytes形式传入
# import json
# import urllib
# from urllib import request, parse
# import ssl
#
# ssl._create_default_https_context = ssl._create_unverified_context


# print('Login to weibo.cn...')
# email = input('Email: ')
# passwd = input('Password: ')
# login_data = parse.urlencode([
#     ('username', email),
#     ('password', passwd),
#     ('entry', 'mweibo'),
#     ('client_id', ''),
#     ('savestate', '1'),
#     ('ec', ''),
#     ('pagerefer',
#      'https://passport.weibo.cn/signin/welcome?entry=\
#      mweibo&r=http%3A%2F%2Fm.weibo.cn%2F')
# ])
#
# req = request.Request('https://passport.weibo.cn/sso/login')
# req.add_header('Origin', 'https://passport.weibo.cn')
# req.add_header('User-Agent', 'Mozilla/6.0 (iPhone; CPU iPhone'
#                              ' OS 8_0 like Mac OS X) AppleWebKit/536.26'
#                              ' (KHTML, like Gecko)'
#                              ' Version/8.0 Mobile/10A5376e Safari/8536.25')
# req.add_header('Referer', 'https://passport.weibo.cn/signin/login?'
#                           'entry=mweibo&res=wel&wm=3349'
#                           '&r=http%3A%2F%2Fm.weibo.cn%2F')
#
# with request.urlopen(req, data=login_data.encode('utf-8')) as f:
#     print('Status:', f.status, f.reason)
#     for k, v in f.getheaders():
#         print('%s: %s' % (k, v))
#     print('Data:', f.read().decode('utf-8'))

# Handler: 如果还需要更复杂的控制，比如通过一个Proxy去访问网站，
# 我们需要利用ProxyHandler来处理，示例代码如下
# proxy_handler = urllib.request.ProxyHandler\
#     ({'http': 'http://www.example.com:3128/'})
# proxy_auth_handler = urllib.request.ProxyBasicAuthHandler()
# proxy_auth_handler.add_password('realm', 'host', 'username', 'password')
# opener = urllib.request.build_opener((proxy_handler, proxy_auth_handler))
# with opener.open('http://www.example.com/login.html') as f:
#     pass

# urllib提供的功能就是利用程序去执行各种HTTP请求。
# 如果要模拟浏览器完成特定功能，需要把请求伪装成浏览器。
# 伪装的方法是先监控浏览器发出的请求，再根据浏览器的请求头来伪装，
# User-Agent头就是用来标识浏览器的。

# def fetch_data(url):
#     with request.urlopen(url) as f:
#         js = json.load(f)
#         return js
#
#
# URL = 'https://query.yahooapis.com/v1/public/yql?q=select%20*%20' \
#       'from%20weather.forecast%20where%20woeid%20%3D%202151330' \
#       '&format=json'
# data = fetch_data(URL)
# print(data)
# assert data['query']['results']['channel']['location']['city'] == 'Beijing'
# print('ok')

# XML
# 操作XML有两种方法：
# DOM和SAX。DOM会把整个XML读入内存，解析为树，因此占用内存大，解析慢，
# 优点是可以任意遍历树的节点。
# SAX是流模式，边读边解析，占用内存小，解析快，缺点是我们需要自己处理事件。
# 正常情况下，优先考虑SAX，因为DOM实在太占内存
# 在Python中使用SAX解析XML非常简洁，
# 通常我们关心的事件是start_element，end_element和char_data，准备好这3个函数，
# 然后就可以解析xml了。

# start_element事件，在读取<a href="/">时；
# char_data事件，在读取python时；
# end_element事件，在读取</a>时。

# from xml.parsers.expat import ParserCreate
#
#
# class DefaultSaxHandler(object):
#
#     def start_element(self, name, attrs):
#         print('sax:start_element: %s, attrs: %s' % (name, str(attrs)))
#
#     def end_element(self, name):
#         print('sax:end_element: %s' % name)
#
#     def char_data(self, text):
#         print('sax:char_data: %s' % text)
#
# xml = xml = r'''<?xml version="1.0"?>
# <ol>
#     <li><a href="/python">Python</a></li>
#     <li><a href="/ruby">Ruby</a></li>
# </ol>
# '''

# 需要注意的是读取一大段字符串时，CharacterDataHandler可能被多次调用，
# 所以需要自己保存起来，在EndElementHandler里面再合并
# handler = DefaultSaxHandler()
# parser = ParserCreate()
# parser.StartElementHandler = handler.start_element
# parser.EndElementHandler = handler.end_element
# parser.CharacterDataHandler = handler.char_data
# parser.Parse(xml)

# import json
# import urllib
# from urllib import request, parse
# from html.parser import HTMLParser
# from html.entities import name2codepoint
# import ssl
#
# ssl._create_default_https_context = ssl._create_unverified_context
#
# class MyHTMLParser(HTMLParser):
#
#     def handle_starttag(self, tag, attrs):
#         print('<%s>' % tag)
#
#     def handle_endtag(self, tag):
#         print('<%s>' % tag)
#
#     def handle_startendtag(self, tag, attrs):
#         print('<%s>' % tag)
#
#     def handle_data(self, data):
#         print(data)
#
#     def handle_comment(self, data):
#         print('<!--', data, '-->')
#
#     def handle_entityref(self, name):
#         print('&%s;' % name)
#
#     def handle_charref(self, name):
#         print('&#%s;' % name)
#
#
# parser = MyHTMLParser()
# parser.feed('''<html>
# <head></head>
# <body>
# <!-- test html parser -->
#     <p>Some <a href=\"#\">html</a> HTML&nbsp;tutorial...<br>END</p>
# # </body></html>''')
#
# # feed()方法可以多次调用，不一定一次把整个HTML字符串都塞进去，可以一部分一部分塞进去。
# # 特殊字符有两种，一种是英文表示的&nbsp;，一种是数字表示的&#1234;，
# # 这两种字符都可以通过Parser解析出来。
#
# from html.parser import HTMLParser
# from html.entities import name2codepoint
# from urllib import request
# import re
#
#
# class MyHTMLParser(HTMLParser):
#     a_t1 = False
#     a_t2 = False
#     a_t3 = False
#
#     def __init__(self):
#         HTMLParser.__init__(self)
#         self.information = []
#         self.information_all = {}
#
#     def handle_starttag(self, tag, attrs):
#         def _attr(attrlist, attrname):
#             for attr in attrlist:
#                 if attr[0] == attrname:
#                     return attr[1]
#             return None
#
#         if tag == "time":
#             self.a_t1 = True
#         # and的用法：
#         # 如果布尔上下文中的所有值都为真，那么 and 返回最后一个值。
#         # 如果布尔上下文中的某个值为假，则 and 返回第一个假值。
#         elif tag == "span" and _attr(attrs, 'class') == "event-location":
#             self.a_t2 = True
#         elif tag == "h3" and _attr(attrs, 'class') == "event-title":
#             self.a_t3 = True
#
#     def handle_data(self, data):
#         if self.a_t1 is True:
#             if re.match(r'^\s\d{4}', data):
#                 self.information.append(dict(year=data))
#             else:
#                 self.information.append(dict(day=data))
#         elif self.a_t2 is True:
#             self.information.append(dict(event_location=data))
#         elif self.a_t3 is True:
#             self.information.append(dict(event_title=data))
#
#     def handle_endtag(self, tag):
#         if tag == "time":
#             self.a_t1 = False
#         elif tag == "span":
#             self.a_t2 = False
#         elif tag == "h3":
#             self.a_t3 = False
#
#
# def parseHTML(html_str):
#     parser = MyHTMLParser()
#     parser.feed(html_str)
#     for i, val in enumerate(parser.information):
#         i += 1
#         print(val)
#         if i % 4 == 0:
#             print('--------------------------------------------')
#
#
# URL = 'https://www.python.org/events/python-events/'
# with request.urlopen(URL, timeout=4) as f:
#     data = f.read()
#
# parseHTML(data.decode('utf-8'))


# from PIL import Image, ImageFilter, ImageDraw, ImageFont
#
# im = Image.open('/Users/yangxudong/Desktop/2.jpeg')
# w, h = im.size
# print('Original image size: %sx%s' % (w, h))
# # 缩放到50%
# im.thumbnail((w//2, h//2))
# print('Resize image to: %sx%s' % (w//2, h//2))
# # 把缩放后的图像用jpeg格式保存
# im.save('thumbnail.jpg', 'jpeg')
# im = Image.open('/Users/yangxudong/Desktop/2.jpeg')
# # 应用模糊滤镜
# im2 = im.filter(ImageFilter.BLUR)
# im2.save('blur.jpg', 'jpeg')
#
#
# # 生成字母验证图片
# import random
#
# # 随机字母
# def rndChar():
#     return chr(random.randint(65, 90))
#
# # 颜色随机1：
# def rndColor():
#     return (random.randint(64, 255), random.randint(64, 255),
#             random.randint(64, 255))
#
# # 随机颜色2
# def rndColor2():
#     return (random.randint(32, 127), random.randint(32, 127),
#             random.randint(32, 127))
#
# # 240x60
# width = 60*4
# height = 60
# image = Image.new('RGB', (width, height), (255, 255, 255))
# # 创建font对象
# font = ImageFont.truetype('Arial.ttf', 36)
# # 创建Draw对象
# draw = ImageDraw.Draw(image)
# # 填充每个像素
# for x in range(width):
#     for y in range(height):
#         draw.point((x, y), fill=rndColor())
# # 输出文字
# for t in range(4):
#     draw.text((60*t+10, 10), rndChar(), font=font, fill=rndColor2())
# # 模糊
# image = image.filter(ImageFilter.BLUR)
# image.save('code.jpg', 'jpeg')

# import requests
#
# # request：POST和get请求，明文和传参。具体情况，具体对待
#
# # 传入cookies参数
# cs = {'token': '12345', 'status': 'working'}
# r = requests.get(url, cookies= cs)
#
# # 指定超时时间
# r = requests.get(url='', timeout=2.5)

# import chardet
# # chardet:检查字符串的编码格式
# # 检测出的编码是ascii，注意到还有个confidence字段，表示检测的概率是1.0（即100%）
# print(chardet.detect(b'Hello, world!'))
#
# # 我们来试试检测GBK编码的中文：
# data = '离离原上草，一岁一枯荣'.encode('gbk')
# print(chardet.detect(data))
#
# # 对UTF-8编码进行检测：
# data = '离离原上草，一岁一枯荣'.encode('utf-8')
# print(chardet.detect(data))
#
# # 对日文进行检测：
# data = '最新の主要ニュース'.encode('euc-jp')
# print(chardet.detect(data))

# 可见，用chardet检测编码，使用简单。获取到编码后，再转换为str，就可以方便后续处理。


# import psutil
# 在Python中获取系统信息的另一个好办法是使用psutil这个第三方模块

# 获取CPU信息
# print(psutil.cpu_count())
# cpu的物理核心
# print(psutil.cpu_count(logical=False))
# 捅进CPU的用户/系统/空闲时间
# print(psutil.cpu_times())
# 实现类似top命令的CPU使用率，每秒刷新一次。累计10次
# for x in range(10):
#     print(psutil.cpu_percent(interval=1, percpu=True))
# 获取内存信息
# 使用psutil获取物理内存和交换内存信息，分别使用：
# 返回的是字节为单位的整数，可以看到，总内存大小是8589934592 = 8 GB，
# 已用7201386496 = 6.7 GB，使用了66.6%
# print(psutil.virtual_memory())
# print(psutil.swap_memory())

# 获取磁盘信息
# 可以通过psutil获取磁盘分区、磁盘使用率和磁盘IO信息：
# 磁盘的分区信息
# print(psutil.disk_partitions())
# 磁盘使用情况
# print(psutil.disk_usage('/'))
# 磁盘IO
# print(psutil.disk_io_counters())

# 获取网络信息：获取网络的接口和网络连接信息
# 获取网络读写字节/包的个数
# print(psutil.net_io_counters())
# 获取网络接口信息
# print(psutil.net_if_addrs())
# 获取网络接口状态
# print(psutil.net_if_stats())
# 获取当前网络连接信息，使用net_connections()
# 你可能会得到一个AccessDenied错误，原因是psutil获取信息也是要走系统接口，
# 而获取网络连接信息需要root权限，这种情况下，可以退出Python交互环境，用sudo重新启动
# print(psutil.net_connections())

# 获取进程信息
# 所有进程ID
# print(psutil.pids())
# 获取指定进程ID=3776，其实就是当前Python交互环境
# p = psutil.Process(3341)
# print(p.name())
# 和获取网络连接类似，获取一个root用户的进程需要root权限，
# 启动Python交互环境或者.py文件时，需要sudo权限。

# virtualenv:
# 创建一套独立的Python运行环境

# 图形界面
# 我们编写的Python代码会调用内置的Tkinter，Tkinter封装了访问Tk的接口；
# Tk是一个图形库，支持多个操作系统，使用Tcl语言开发；
# Tk会调用操作系统提供的本地GUI接口，完成最终的GUI。
# 所以，我们的代码只需要调用Tkinter提供的接口就可以了。

# 第一个GUI程序
# from tkinter import *
#
#
# class Application(Frame):
#
#     def __init__(self, master=None):
#         Frame.__init__(self, master)
#         self.quitButton = Button(self, text='Quit', command=self.quit)
#         self.helloLabel = Label(self, text='Hello world')
#         self.pack()
#         self.createWidgets()
#
#     def createWidgets(self):
#         self.helloLabel.pack()
#         self.quitButton.pack()
#
#
# # 实例化Application，并启动消息循环
# # app = Application()
# # 设置窗口标题：
# # app.master.title('Hello World')
# # 主消息循环：
# # app.mainloop()
#
#
# # 输入文本
# import tkinter.messagebox as messagebox
#
#
# class Application(Frame):
#
#     def __init__(self, master=None):
#         Frame.__init__(self, master)
#         self.alertButton = Button(self, text='Hello', command=self.hello)
#         self.nameInput = Entry(self)
#         self.pack()
#         self.createWidgets()
#
#     def createWidgets(self):
#         self.nameInput.pack()
#         self.alertButton.pack()
#
#     def hello(self):
#         name = self.nameInput.get() or 'world'
#         messagebox.showinfo('Message', 'Hello, %s' % name)
#
#
# app = Application()
# app.master.title('Hello World')
# app.mainloop()


# TCP编程
# 创建一个基于TCP连接的Socket
import socket, threading, time

# 创建一个socket
# s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
# 建立连接
# s.connect(('www.sina.com.cn', 80))
# 建立TCP连接后，我们就可以向新浪服务器发送请求，要求返回首页的内容：
# s.send(b'GET / HTTP/1.1\r\nHost: www.sina.com.cn\r\nConnection:'
#        b' close\r\n\r\n')
# 接受数据
# 接收数据时，调用recv(max)方法，一次最多接收指定的字节数，
# 因此，在一个while循环中反复接收，直到recv()返回空数据，表示接收完毕，退出循环。
# buffer = []
# while True:
#     # 每次最多接受1k字节
#     d = s.recv(1024)
#     if d:
#         buffer.append(d)
#     else:
#         break
# data = b''.join(buffer)
# print(data)

# 当我们接收完数据后，调用close()方法关闭Socket，这样，一次完整的网络通信就结束了
# s.close()

# 接收到的数据包括HTTP头和网页本身，我们只需要把HTTP头和网页分离一下，
# 把HTTP头打印出来，网页内容保存到文件
# 现在，只需要在浏览器中打开这个sina.html文件，就可以看到新浪的首页了
# header, html = data.split(b'\r\n\r\n', 1)
# print(header.decode('utf-8'))
# 把接受数据写入文件
# with open('sina.html', 'wb') as f:
#     f.write(html)



# 服务器
# 服务器进程首先要绑定一个端口并监听来自其他客户端的连接。
# 如果某个客户端连接过来了，服务器就与该客户端建立Socket连接，
# 随后的通信就靠这个Socket连接了

# 一个Socket依赖4项：服务器地址、服务器端口、客户端地址、客户端端口来唯一确定一个Socket。
# 编写一个简单的服务器程序，它接收客户端连接，把客户端发过来的字符串加上Hello再发回去
# 首先，创建一个基于IPv4和TCP协议的Socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
# 端口号需要预先指定。因为我们写的这个服务不是标准服务，所以用9999这个端口号。
# 请注意，小于1024的端口号必须要有管理员权限才能绑定：

# 监听端口号
# 127.0.0.1是一个特殊的IP地址，表示本机地址，如果绑定到这个地址，
# 客户端必须同时在本机运行才能连接，也就是说，外部的计算机无法连接进来。
s.bind(('127.0.0.1', 9999))
# 紧接着，调用listen()方法开始监听端口，传入的参数指定等待连接的最大数量：
s.listen(5)
print('Waiting for connection...')
# 接下来，服务器程序通过一个永久循环来接受来自客户端的连接，
# accept()会等待并返回一个客户端的连接:
while True:
    # 接受一个新的连接
    sock, addr = s.accept()
    # 创建新线程来处理TCP连接
    t = threading.Thread(target=tcplink, args=(sock, addr))
    t.start()


# 每个连接都必须创建新线程（或进程）来处理，
# 否则，单线程在处理连接的过程中，无法接受其他客户端的连接：
    def tcplink(sock, addr):
        print('Accept new connection from %s:%s...' % addr)
        sock.send(b'Welcome')
        while True:
            data = sock.recv(1024)
            time.sleep(1)
            if not data or data.decode('utf-8') == 'exit':
                break
            sock.send(('Hello, %s' % data.decode('utf-8')).encode('utf-8'))
        sock.close()
        print('Connection from %s:%s closed.' % addr)

# 连接建立后，服务器首先发一条欢迎消息，然后等待客户端数据，
# 并加上Hello再发送给客户端。如果客户端发送了exit字符串，就直接关闭连接。



