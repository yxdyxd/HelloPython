# # # # # # # # # # # # #!/usr/bin/env python3
# # # # # # # # # # # # # -*- coding: utf-8 -*-
# # # # # # # # # # # #
# # # # # # # # # # # # # print('hello world')
# # # # # # # # # # # #
# # # # # # # # # # # # # name = input('please enter your name: ')
# # # # # # # # # # # # # print('hello,', name)
# # # # # # # # # # # #
# # # # # # # # # # # # # print(type(name))
# # # # # # # # # # # #
# # # # # # # # # # # # # age = 4
# # # # # # # # # # # # #
# # # # # # # # # # # # # if age >= 18:
# # # # # # # # # # # # #     print ("123")
# # # # # # # # # # # # # else:
# # # # # # # # # # # # #     print ("456")
# # # # # # # # # # # # #
# # # # # # # # # # # # # a = 123 #a 是整数
# # # # # # # # # # # # # print(a)
# # # # # # # # # # # # # b = 'ABC' #b为字符串
# # # # # # # # # # # # # print(b)
# # # # # # # # # # # #
# # # # # # # # # # # # # 导入实除法模块后的结果即为浮点数
# # # # # # # # # # # # # from __future__ import division
# # # # # # # # # # # # # a = 10 / 3
# # # # # # # # # # # # # print(a)
# # # # # # # # # # # #
# # # # # # # # # # # #
# # # # # # # # # # # # # def power(x, n):
# # # # # # # # # # # # #     s = 1
# # # # # # # # # # # # #     while n > 0:
# # # # # # # # # # # # #         n = n - 1
# # # # # # # # # # # # #         s = s * x
# # # # # # # # # # # # #     return s
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # print (power(3, 3))
# # # # # # # # # # # #
# # # # # # # # # # # #
# # # # # # # # # # # # # def power(x, n=2):
# # # # # # # # # # # # #     s = 1
# # # # # # # # # # # # #     while n > 0:
# # # # # # # # # # # # #         n = n - 1
# # # # # # # # # # # # #         s = s * x
# # # # # # # # # # # # #     return s
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # print ('power2 = %d' % power(5))
# # # # # # # # # # # # #
# # # # # # # # # # # # # # 多个占位符
# # # # # # # # # # # # # s = "I am %s,age %d" % ('alex', 18)
# # # # # # # # # # # # # print(s)
# # # # # # # # # # # #
# # # # # # # # # # # # # 不添加默认的参数
# # # # # # # # # # # # # def enroll(name, gender):
# # # # # # # # # # # # #     print('name: %s' % name)
# # # # # # # # # # # # #     print('gender: %s' % gender)
# # # # # # # # # # # # #     return
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # enroll('jack', 'boy')
# # # # # # # # # # # #
# # # # # # # # # # # #
# # # # # # # # # # # # # 添加默认的参数
# # # # # # # # # # # # # def enroll(name, gender, age=6, city='Beijing'):
# # # # # # # # # # # # #     print('name: %s' % name)
# # # # # # # # # # # # #     print('gender: %s' % gender)
# # # # # # # # # # # # #     print('age: %d' % age)
# # # # # # # # # # # # #     print('city: %s' % city)
# # # # # # # # # # # #
# # # # # # # # # # # #
# # # # # # # # # # # # # enroll('Lucy', 'girl')
# # # # # # # # # # # # # enroll('Bod', 'Boy', 17)
# # # # # # # # # # # # # enroll('Adam', 'Boy', 20, city='Tianjin')
# # # # # # # # # # # # # enroll('jack', 'boy', 20, 'Tianjin')
# # # # # # # # # # # #
# # # # # # # # # # # # # 添加默认参数的坑
# # # # # # # # # # # # # def add_end(L=[]):
# # # # # # # # # # # # #     L.append('end')
# # # # # # # # # # # # #     return L
# # # # # # # # # # # #
# # # # # # # # # # # #
# # # # # # # # # # # # # 多次调用默认函数
# # # # # # # # # # # # # print(add_end())
# # # # # # # # # # # # # print(add_end())
# # # # # # # # # # # # # 此处打印，本应为一个'end'，结果打印了三个
# # # # # # # # # # # # # 定义默认参数：默认参数必须指向不变对象
# # # # # # # # # # # # # print(add_end())
# # # # # # # # # # # #
# # # # # # # # # # # #
# # # # # # # # # # # # # 默认参数的正确写法
# # # # # # # # # # # # # def add_end(L=None):
# # # # # # # # # # # # #     if L is None:
# # # # # # # # # # # # #         L = []
# # # # # # # # # # # # #     L.append('END')
# # # # # # # # # # # # #     return L
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # print(add_end())
# # # # # # # # # # # # # print(add_end())
# # # # # # # # # # # # # print(add_end())
# # # # # # # # # # # #
# # # # # # # # # # # # # 可变参数
# # # # # # # # # # # # # def calc(numbers):
# # # # # # # # # # # # #     sum = 0
# # # # # # # # # # # # #     for n in numbers:
# # # # # # # # # # # # #         sum = sum + n * n
# # # # # # # # # # # # #     return sum
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # # print(calc([1, 2, 3]))
# # # # # # # # # # # # # # print(calc([1, 3, 5, 7]))
# # # # # # # # # # # # #
# # # # # # # # # # # # # # print(calc([]))
# # # # # # # # # # # # # # 此处传入的参数应为空list或tuple，传入为空会报错
# # # # # # # # # # # # # # print(calc())
# # # # # # # # # # # # #
# # # # # # # # # # # # # # 1.重写此方法，在number前加上*号，将接受的参数变为可变参数
# # # # # # # # # # # # # # 2.加上*号，接收到的number依然是list或者tuple，函数代码完全不变
# # # # # # # # # # # # # def calc(*numbers):
# # # # # # # # # # # # #     sum = 0
# # # # # # # # # # # # #     for n in numbers:
# # # # # # # # # # # # #         sum = sum + n * n
# # # # # # # # # # # # #     return sum
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # # print(calc(1, 2, 3))
# # # # # # # # # # # # # # print(calc())
# # # # # # # # # # # # #
# # # # # # # # # # # # # # 假如传入的为list或者tuple，加上*即可
# # # # # # # # # # # # # # *nums表示把nums这个list的所有元素作为可变参数传进去
# # # # # # # # # # # # # nums = [1, 2, 3]
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # # print(calc(*nums))
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # def person(name, age, **kw):
# # # # # # # # # # # # #     print('name:', name, 'age:', age, \
# # # # # # # # # # # # #           'other:', kw)
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # # person('jack', 30)
# # # # # # # # # # # # # # person('tom', 28, city='Beijing')
# # # # # # # # # # # # # # person('bob', 12, gender='boy', city='Tianjin')
# # # # # # # # # # # # #
# # # # # # # # # # # # # extra = {'city': 'Beijing', 'job': 'Engineer'}
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # # 注意kw获得的dict是extra的一份拷贝，对kw的改动\
# # # # # # # # # # # # # # 不会影响到函数外的extra，作用是可以添加额外的参数
# # # # # # # # # # # # # # person('mike', 23, **extra)
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # # 关键字参数
# # # # # # # # # # # # # # def person(name, age, **kw):
# # # # # # # # # # # # # #     if 'city' in kw:
# # # # # # # # # # # # # #         # 有city参数
# # # # # # # # # # # # # #         pass
# # # # # # # # # # # # # #     if 'job' in kw:
# # # # # # # # # # # # # #         # 有job参数
# # # # # # # # # # # # # #         pass
# # # # # # # # # # # # # #     print('name:%s' % name, 'age:%d' % age, 'other:', kw)
# # # # # # # # # # # # #
# # # # # # # # # # # # # # person('jack', 21, city='Beijing', addr='Chaoyang',\
# # # # # # # # # # # # # #        zipcode=12345)
# # # # # # # # # # # # #
# # # # # # # # # # # # # def person(name, age, *, city, job):
# # # # # # # # # # # # #     print(name, age, city, job)
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # # person('jack', 24, city='Beijing', job='Engineer')
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # def person(name, age, *args, city, job):
# # # # # # # # # # # # #     print(name, age, args, city, job)
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # # 此处调用时，需要参数名（city， job），否则就会报错
# # # # # # # # # # # # # # person('jack', 25, city='Beijing', job='teacher')
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # # 添加默认的关键字参数
# # # # # # # # # # # # # def person(name, age, *, city='Beijing', job):
# # # # # # # # # # # # #     print(name, age, city, job)
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # # person('mike', 32, job='student')
# # # # # # # # # # # # # # 也可以在外部更改默认的关键字参数，可以传入空值
# # # # # # # # # # # # # # person('mike', 21, city='Tianjin', job='student')
# # # # # # # # # # # # # # person('mike', 21, city='', job='student')
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # # 参数的组合：
# # # # # # # # # # # # # # 定义参数的顺序为：必选参数、默认参数、可变参数、
# # # # # # # # # # # # # # 命名关键字参数、关键字参数
# # # # # # # # # # # # #
# # # # # # # # # # # # # # 定义一个参数，包含上述若干种参数
# # # # # # # # # # # # #
# # # # # # # # # # # # # def f1(a, b, c=0, *args, **kw):
# # # # # # # # # # # # #     print('a =', a, 'b =', b, 'c =', c, 'args =', args, \
# # # # # # # # # # # # #           'kw =', kw)
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # # f1(1, 2)
# # # # # # # # # # # # # # f1(1, 2, c=3, city='Beijing')
# # # # # # # # # # # # # # f1(1, 2, 3, '1', '2')
# # # # # # # # # # # # # # f1(1, 2, 0, 1, 2, 3, city='Beijing')
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # def f2(a, b, c=0, *, d, **kw):
# # # # # # # # # # # # #     print('a2 =', a, 'b =', b, 'c =', c, 'd =', d,\
# # # # # # # # # # # # #           'kw =', kw)
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # # f2(3, 4, 5, d=6, student=23)
# # # # # # # # # # # # #
# # # # # # # # # # # # # # 通过tuple或者dict也可以调用上述函数
# # # # # # # # # # # # # args = (1, 2, 3, 4)
# # # # # # # # # # # # # kw = {'q': 00, 'x': 'y'}
# # # # # # # # # # # # #
# # # # # # # # # # # # # # f1(*args, **kw)
# # # # # # # # # # # # #
# # # # # # # # # # # # # args = (1, 2, 3)
# # # # # # # # # # # # # kw = {'d': 00, 'x': 'y'}
# # # # # # # # # # # # # # f2(*args, **kw)
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # def product(x, y):
# # # # # # # # # # # # #     return x * y
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # def product(a, *args):
# # # # # # # # # # # # #     sum = a
# # # # # # # # # # # # #     for n in args:
# # # # # # # # # # # # #         sum = sum*n
# # # # # # # # # # # # #     return sum
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # print('product(5) =', product(5))
# # # # # # # # # # # # # print('product(5, 6) =', product(5, 6))
# # # # # # # # # # # # # print('product(5, 6, 7) =', product(5, 6, 7))
# # # # # # # # # # # # # print('product(5, 6, 7, 9) =', product(5, 6, 7, 9))
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # if product(5) != 5:
# # # # # # # # # # # # #     print('测试失败!')
# # # # # # # # # # # # # elif product(5, 6) != 30:
# # # # # # # # # # # # #     print('测试失败!')
# # # # # # # # # # # # # elif product(5, 6, 7) != 210:
# # # # # # # # # # # # #     print('测试失败!')
# # # # # # # # # # # # # elif product(5, 6, 7, 9) != 1890:
# # # # # # # # # # # # #     print('测试失败!')
# # # # # # # # # # # # # else:
# # # # # # # # # # # # #     try:
# # # # # # # # # # # # #         product()
# # # # # # # # # # # # #         print('测试失败!')
# # # # # # # # # # # # #     except TypeError:
# # # # # # # # # # # # #         print('测试成功!')
# # # # # # # # # # # #
# # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # #
# # # # # # # # # # # #
# # # # # # # # # # # # # def fact(n):
# # # # # # # # # # # # #     if n == 1:
# # # # # # # # # # # # #         return 1
# # # # # # # # # # # # #     return n * fact(n - 1)
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # # print(fact(1))
# # # # # # # # # # # # # # print(fact(5))
# # # # # # # # # # # # # # print(fact(1000))
# # # # # # # # # # # # #
# # # # # # # # # # # # # # 上边的方式会造成栈的溢出
# # # # # # # # # # # # # # 解决方法是通过尾递归优化，在函数返回是，调用本身，并且不包含表达式
# # # # # # # # # # # # #
# # # # # # # # # # # # # def fact(n):
# # # # # # # # # # # # #     return fact_iter(n, 1)
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # def fact_iter(num, product):
# # # # # # # # # # # # #     if num == 1:
# # # # # # # # # # # # #         return product
# # # # # # # # # # # # #     return fact_iter(num - 1, num * product)
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # print(fact_iter(10, 1))
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # def move(n, a, b, c):
# # # # # # # # # # # # #     if n == 1:
# # # # # # # # # # # # #         print(a, '-->', c)
# # # # # # # # # # # # #     else:
# # # # # # # # # # # # #         move(n - 1, a, c, b)
# # # # # # # # # # # # #         move(1, a, b, c)
# # # # # # # # # # # # #         move(n - 1, b, a, c)
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # # 递归赋值（话说网上真的是能人辈出）
# # # # # # # # # # # # # # print(move(3, 'A', 'B', 'C'))
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # # 切片
# # # # # # # # # # # # # L = ['mike', 'bob', 'jack', 'lucy', 'tom']
# # # # # # # # # # # # # # 取出前三个元素
# # # # # # # # # # # # # print(L[0:3])
# # # # # # # # # # # # # # 如果包含第一个元素的话，可以将0省略
# # # # # # # # # # # # # print(L[:3])
# # # # # # # # # # # # # # 取出第二三个元素
# # # # # # # # # # # # # print(L[1:3])
# # # # # # # # # # # # # # 也可倒数切片，例如-1
# # # # # # # # # # # # # print(L[-2:])
# # # # # # # # # # # # # print(L[-2:-1])
# # # # # # # # # # # # #
# # # # # # # # # # # # # # 取数练习
# # # # # # # # # # # # # b = list(range(100))
# # # # # # # # # # # # # print(b[:10])
# # # # # # # # # # # # # print(b[-10:])
# # # # # # # # # # # # # print(b[10:20])
# # # # # # # # # # # # # # 前十个数，每隔两个取一个
# # # # # # # # # # # # # print(b[:10:2])
# # # # # # # # # # # # # # 所有数，每5个取一个
# # # # # # # # # # # # # print(b[::5])
# # # # # # # # # # # # # # 取出所有数
# # # # # # # # # # # # # # print(b[:])
# # # # # # # # # # # # # # 字符串也可用来切片
# # # # # # # # # # # # # # 但是针对字符串的截取，有各种的系统方法(例如，substring)
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # str = '  hello  '
# # # # # # # # # # # # # print(str[:1])
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # def trim(s):
# # # # # # # # # # # # #     if s[:1] == " ":
# # # # # # # # # # # # #         return trim(s[1:])
# # # # # # # # # # # # #     if s[-1:] == " ":
# # # # # # # # # # # # #         return trim(s[:-1])
# # # # # # # # # # # # #     return s
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # if trim('hello  ') != 'hello':
# # # # # # # # # # # # #     print('测试失败!')
# # # # # # # # # # # # # elif trim('  hello') != 'hello':
# # # # # # # # # # # # #     print('测试失败!')
# # # # # # # # # # # # # elif trim('  hello  ') != 'hello':
# # # # # # # # # # # # #     print('测试失败!')
# # # # # # # # # # # # # elif trim('  hello  world  ') != 'hello  world':
# # # # # # # # # # # # #     print('测试失败!')
# # # # # # # # # # # # # elif trim('') != '':
# # # # # # # # # # # # #     print('测试失败!')
# # # # # # # # # # # # # elif trim('    ') != '':
# # # # # # # # # # # # #     print('测试失败!')
# # # # # # # # # # # # # else:
# # # # # # # # # # # # #     print('测试成功!')
# # # # # # # # # # # #
# # # # # # # # # # # #
# # # # # # # # # # # # # d = {'a': 1, 'b': 2, 'c': 3}
# # # # # # # # # # # # # # Python中的遍历循环，称之为迭代
# # # # # # # # # # # # # # 迭代dict中的key
# # # # # # # # # # # # # for key in d:
# # # # # # # # # # # # #     print(key)
# # # # # # # # # # # # #
# # # # # # # # # # # # # # 迭代dict中的Value
# # # # # # # # # # # # # for value in d.values():
# # # # # # # # # # # # #     print(value)
# # # # # # # # # # # # #
# # # # # # # # # # # # # # 迭代dict中的Value和key
# # # # # # # # # # # # # for k, v in d.items():
# # # # # # # # # # # # #     print(k, v)
# # # # # # # # # # # # #
# # # # # # # # # # # # # # 字符串也可以迭代
# # # # # # # # # # # # # for ch in 'ABC':
# # # # # # # # # # # # #     print(ch)
# # # # # # # # # # # # #
# # # # # # # # # # # # # # 判断一个对象是否可迭代
# # # # # # # # # # # # # from collections import Iterable
# # # # # # # # # # # # # print(isinstance('abc', Iterable))
# # # # # # # # # # # # # print(isinstance([1, 2, 3], Iterable))
# # # # # # # # # # # # # # 整数不能迭代
# # # # # # # # # # # # # print(isinstance(123, Iterable))
# # # # # # # # # # # # #
# # # # # # # # # # # # # # Python内置的enumerate函数可以把一个list变成索引-元素对
# # # # # # # # # # # # # for i, value in enumerate(['A', 'B', 'c']):
# # # # # # # # # # # # #     print(i, value)
# # # # # # # # # # # # #
# # # # # # # # # # # # # for x, y in ([1, 1], [2, 4], [3, 9]):
# # # # # # # # # # # # #     print(x, y)
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # # 请使用迭代查找一个list中最小和最大值，并返回一个tuple
# # # # # # # # # # # # # def findMinAndMax(L):
# # # # # # # # # # # # #     if L == []:
# # # # # # # # # # # # #         return (None, None)
# # # # # # # # # # # # #     else:
# # # # # # # # # # # # #         MIN = L[0]
# # # # # # # # # # # # #         MAX = L[0]
# # # # # # # # # # # # #         for X in L:
# # # # # # # # # # # # #             if MIN >= X:
# # # # # # # # # # # # #                 MIN = X
# # # # # # # # # # # # #             elif MAX <= X:
# # # # # # # # # # # # #                 MAX = X
# # # # # # # # # # # # #         return (MIN, MAX)
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # if findMinAndMax([]) != (None, None):
# # # # # # # # # # # # #     print('测试失败!')
# # # # # # # # # # # # # elif findMinAndMax([7]) != (7, 7):
# # # # # # # # # # # # #     print('测试失败!')
# # # # # # # # # # # # # elif findMinAndMax([7, 1]) != (1, 7):
# # # # # # # # # # # # #     print('测试失败!')
# # # # # # # # # # # # # elif findMinAndMax([7, 1, 3, 9, 5]) != (1, 9):
# # # # # # # # # # # # #     print('测试失败!')
# # # # # # # # # # # # # else:
# # # # # # # # # # # # #     print('测试成功!')
# # # # # # # # # # # #
# # # # # # # # # # # #
# # # # # # # # # # # # # print(list(range(1, 11)))
# # # # # # # # # # # # # # 列表生成式，快速生成list
# # # # # # # # # # # # #
# # # # # # # # # # # # # L = []
# # # # # # # # # # # # # for x in range(1, 11):
# # # # # # # # # # # # #     L.append(x * x)
# # # # # # # # # # # # # print(L)
# # # # # # # # # # # # #
# # # # # # # # # # # # # #在列表生成式中，可以使用运算式，来得到自己想要的list
# # # # # # # # # # # # # print([x*x for x in range(1, 11)])
# # # # # # # # # # # # #
# # # # # # # # # # # # # # or循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方
# # # # # # # # # # # # # print([x*x for x in range(1, 11) if x % 2 ==0])
# # # # # # # # # # # # #
# # # # # # # # # # # # # # 还可以使用两层循环，可以生成全排列
# # # # # # # # # # # # # print([m + n for m in 'ABC' for n in 'XYZ'])
# # # # # # # # # # # # #
# # # # # # # # # # # # # # 导入os模块
# # # # # # # # # # # # # import os
# # # # # # # # # # # # # # os.listdir可以列出文件和目录
# # # # # # # # # # # # # print([d for d in os.listdir('.')])
# # # # # # # # # # # # #
# # # # # # # # # # # # # # for循环其实可以同时使用两个甚至多个变量
# # # # # # # # # # # # # # 比如dict的items()可以同时迭代key和value
# # # # # # # # # # # # # d = {'x': 'A', 'y': 'B', 'z': 'C'}
# # # # # # # # # # # # # for k, v in d.items():
# # # # # # # # # # # # #     print(k, '=', v)
# # # # # # # # # # # # #
# # # # # # # # # # # # # # 列表生成式也可以使用两个变量来生成list
# # # # # # # # # # # # # print([k + '=' + v for k, v in d.items()])
# # # # # # # # # # # # #
# # # # # # # # # # # # # # 把一个list中所有的字符串变成小写
# # # # # # # # # # # # # L = ['Hello', 'World', 'IBM', 'Apple']
# # # # # # # # # # # # # print([s.lower() for s in L])
# # # # # # # # # # # # # # 把一个list中所有的字符串变成大写
# # # # # # # # # # # # # print([s.upper() for s in L])
# # # # # # # # # # # # #
# # # # # # # # # # # # # # 使用内建的isinstance函数可以判断一个变量是不是字符串
# # # # # # # # # # # # # x = 'abc'
# # # # # # # # # # # # # y = 123
# # # # # # # # # # # # # z = ''
# # # # # # # # # # # # # print(isinstance(x, str))
# # # # # # # # # # # # # # 也可用来判断是否是数字
# # # # # # # # # # # # # print(isinstance(y, int))
# # # # # # # # # # # # # # 判断是否为空
# # # # # # # # # # # # # print(isinstance(z, str))
# # # # # # # # # # # # #
# # # # # # # # # # # # # # 修改列表生成式，通过添加if语句保证列表生成式能正确地执行
# # # # # # # # # # # # # L1 = ['Hello', 'World', 18, 'Apple', None]
# # # # # # # # # # # # #
# # # # # # # # # # # # # L2 = [s.lower() for s in L1 if isinstance(s, str)]
# # # # # # # # # # # # #
# # # # # # # # # # # # # # 测试:
# # # # # # # # # # # # # print(L2)
# # # # # # # # # # # # # if L2 == ['hello', 'world', 'apple']:
# # # # # # # # # # # # #     print('测试通过!')
# # # # # # # # # # # # # else:
# # # # # # # # # # # # #     print('测试失败!')
# # # # # # # # # # # #
# # # # # # # # # # # #
# # # # # # # # # # # # # L = [x*x for x in range(10)]
# # # # # # # # # # # # # # print(L)
# # # # # # # # # # # # # g = (x*x for x in range(10))
# # # # # # # # # # # # # # 在Python中，这种一边循环一边计算的机制，称为生成器：generator
# # # # # # # # # # # # # # 创建L和g的区别仅在于最外层的[]和()
# # # # # # # # # # # # # # L是一个list，而g是一个generator
# # # # # # # # # # # # # # generator并没有创建一个完整的数组，而是在不断的调用中生成
# # # # # # # # # # # # # # 主要的目的在于节省空间
# # # # # # # # # # # # # # print(g)
# # # # # # # # # # # # #
# # # # # # # # # # # # # #打印g中的所有元素
# # # # # # # # # # # # # # for n in g:
# # # # # # # # # # # # # #     print(n)
# # # # # # # # # # # # #
# # # # # # # # # # # # # # generator非常强大。如果推算的算法比较复杂
# # # # # # # # # # # # # # 用类似列表生成式的for循环无法实现的时候，还可以用函数来实现
# # # # # # # # # # # # # def fib(max):
# # # # # # # # # # # # #     n, a, b = 0, 0, 1
# # # # # # # # # # # # #     while n < max:
# # # # # # # # # # # # #         print(b)
# # # # # # # # # # # # #         a, b = b, a + b
# # # # # # # # # # # # #         n = n + 1
# # # # # # # # # # # # #     return 'done'
# # # # # # # # # # # # #
# # # # # # # # # # # # # # fib(6)
# # # # # # # # # # # # #
# # # # # # # # # # # # # # 修改上边函数为generator
# # # # # # # # # # # # # # 要把fib函数变成generator，只需要把print(b)改为yield b就可以了
# # # # # # # # # # # # # def fib(max):
# # # # # # # # # # # # #     n, a, b = 0, 0, 1
# # # # # # # # # # # # #     while n < max:
# # # # # # # # # # # # #         yield b
# # # # # # # # # # # # #         a, b = b, a + b
# # # # # # # # # # # # #         n = n + 1
# # # # # # # # # # # # #     return 'done'
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # f = fib(6)
# # # # # # # # # # # # # print(f)
# # # # # # # # # # # # # # 这是定义generator的另一种方法。如果一个函数定义中包含yield关键字
# # # # # # # # # # # # # # 那么这个函数就不再是一个普通函数，而是一个generator
# # # # # # # # # # # # # # for n in fib(6):
# # # # # # # # # # # # # #     print(n)
# # # # # # # # # # # # #
# # # # # # # # # # # # # # 捕获错误的发生
# # # # # # # # # # # # # # g = fib(6)
# # # # # # # # # # # # # # while True:
# # # # # # # # # # # # # #     try:
# # # # # # # # # # # # # #         x = next(g)
# # # # # # # # # # # # # #         print('g:', x)
# # # # # # # # # # # # # #     except StopIteration as e:
# # # # # # # # # # # # # #         print('Generator return value:', e.value)
# # # # # # # # # # # # # #         break
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # def triangles():
# # # # # # # # # # # # #     tr = [1]
# # # # # # # # # # # # #     while True:
# # # # # # # # # # # # #         yield tr
# # # # # # # # # # # # #         ntr = tr[:]
# # # # # # # # # # # # #         for i in range(len(tr)):
# # # # # # # # # # # # #             if i == 0:
# # # # # # # # # # # # #                 ntr[i] = 1
# # # # # # # # # # # # #             else:
# # # # # # # # # # # # #                 ntr[i] = tr[i] + tr[i-1]
# # # # # # # # # # # # #         ntr.append(1)
# # # # # # # # # # # # #         tr = ntr[:]
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # n = 0
# # # # # # # # # # # # # results = []
# # # # # # # # # # # # # for t in triangles():
# # # # # # # # # # # # #     print(t)
# # # # # # # # # # # # #     results.append(t)
# # # # # # # # # # # # #     n = n + 1
# # # # # # # # # # # # #     if n == 10:
# # # # # # # # # # # # #         break
# # # # # # # # # # # # # if results == [
# # # # # # # # # # # # #     [1],
# # # # # # # # # # # # #     [1, 1],
# # # # # # # # # # # # #     [1, 2, 1],
# # # # # # # # # # # # #     [1, 3, 3, 1],
# # # # # # # # # # # # #     [1, 4, 6, 4, 1],
# # # # # # # # # # # # #     [1, 5, 10, 10, 5, 1],
# # # # # # # # # # # # #     [1, 6, 15, 20, 15, 6, 1],
# # # # # # # # # # # # #     [1, 7, 21, 35, 35, 21, 7, 1],
# # # # # # # # # # # # #     [1, 8, 28, 56, 70, 56, 28, 8, 1],
# # # # # # # # # # # # #     [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]
# # # # # # # # # # # # # ]:
# # # # # # # # # # # # #     print('测试通过!')
# # # # # # # # # # # # # else:
# # # # # # # # # # # # #     print('测试失败!')
# # # # # # # # # # # #
# # # # # # # # # # # #
# # # # # # # # # # # # # from collections import Iterable
# # # # # # # # # # # # #
# # # # # # # # # # # # # # 可以直接作用于for循环的对象统称为迭代对象：Iterable
# # # # # # # # # # # # # # 使用isinstance()判断一个对象是否为Iterable
# # # # # # # # # # # # # # print(isinstance([], Iterable))
# # # # # # # # # # # # # # print(isinstance(123, Iterable))
# # # # # # # # # # # # # # print(isinstance((x for x in range(10)), Iterable))
# # # # # # # # # # # # #
# # # # # # # # # # # # # # 可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator
# # # # # # # # # # # # # # 可以使用isinstance()判断一个对象是否是Iterator对象
# # # # # # # # # # # # # from collections import Iterator
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # # print(isinstance('abc', Iterator))
# # # # # # # # # # # # # # print(isinstance((x for x in range(10)), Iterator))
# # # # # # # # # # # # # # 把list、dict、str等Iterable变成Iterator可以使用iter()函数
# # # # # # # # # # # # # # print(isinstance(iter([]), Iterator))
# # # # # # # # # # # # # # print(isinstance(iter('abc'), Iterator))
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # # 函数名也是变量，可以通过赋值把一个整数赋值给函数名
# # # # # # # # # # # # # # 既然变量可以指向函数，函数的参数能接收变量
# # # # # # # # # # # # # # 那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数
# # # # # # # # # # # # # # 列举一个简单的高阶函数
# # # # # # # # # # # # # def add(x, y, f):
# # # # # # # # # # # # #     return f(x) + f(y)
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # # print(add(-5, 6, abs))
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # # map()函数接收两个参数，一个是函数，一个是Iterable
# # # # # # # # # # # # # # 一个函数f(x)=x2(x的平方)
# # # # # # # # # # # # # # 把这个函数作用在一个list [1, 2, 3, 4, 5, 6, 7, 8, 9]上
# # # # # # # # # # # # # def f(x):
# # # # # # # # # # # # #     return x * x
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
# # # # # # # # # # # # # # print(list(r))
# # # # # # # # # # # # #
# # # # # # # # # # # # # # reduce把一个函数作用在一个序列[x1, x2, x3, ...]上
# # # # # # # # # # # # # # 这个函数必须接收两个参数
# # # # # # # # # # # # # # reduce把结果继续和序列的下一个元素做累积计算
# # # # # # # # # # # # # # 等价于:reduce(f,[x1, x2, x3, x4]) = f(f(f(x1, x2), x3),x4)
# # # # # # # # # # # # # from functools import reduce
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # def add(x, y):
# # # # # # # # # # # # #     return x + y
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # # print(reduce(add, [1, 3, 5, 7, 9]))
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # def fn(x, y):
# # # # # # # # # # # # #     return x * 10 + y
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # print(reduce(fn, [1, 3, 5, 7, 9]))
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # def charm2num(s):
# # # # # # # # # # # # #     digits = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, \
# # # # # # # # # # # # #               '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}
# # # # # # # # # # # # #     return digits[s]
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # # print(reduce(fn, map(charm2num, '13579')))
# # # # # # # # # # # # # #
# # # # # # # # # # # # # # print(charm2num('5'))
# # # # # # # # # # # # # # print(list(map(charm2num, '12345')))
# # # # # # # # # # # # #
# # # # # # # # # # # # # DIGITS = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, \
# # # # # # # # # # # # #           '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # def str2int(s):
# # # # # # # # # # # # #     def fn(x, y):
# # # # # # # # # # # # #         return x * 10 + y
# # # # # # # # # # # # #
# # # # # # # # # # # # #     def charm2num(s):
# # # # # # # # # # # # #         return DIGITS[s]
# # # # # # # # # # # # #
# # # # # # # # # # # # #     return reduce(fn, map(charm2num, s))
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # # print(str2int('123456'))
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # # 继续简化
# # # # # # # # # # # # # def charm2num(s):
# # # # # # # # # # # # #     return DIGITS[s]
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # def str2int(s):
# # # # # # # # # # # # #     return reduce(lambda x, y: x * 10 + y, map(charm2num, s))
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # # print(str2int('1234'))
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # def normalize(name):
# # # # # # # # # # # # #     str1 = name[:1].upper() + name[1:].lower()
# # # # # # # # # # # # #     return str1
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # L1 = ['adam', 'LISA', 'barT']
# # # # # # # # # # # # # L2 = list(map(normalize, L1))
# # # # # # # # # # # # # print(L2)
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # def prod(L):
# # # # # # # # # # # # #     def sum1(x, y):
# # # # # # # # # # # # #         return x * y
# # # # # # # # # # # # #
# # # # # # # # # # # # #     return reduce(sum1, L)
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # print('3 * 5 * 7 * 9 =', prod([3, 5, 7, 9]))
# # # # # # # # # # # # # if prod([3, 5, 7, 9]) == 945:
# # # # # # # # # # # # #     print('测试成功!')
# # # # # # # # # # # # # else:
# # # # # # # # # # # # #     print('测试失败!')
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # def str2float(s):
# # # # # # # # # # # # #     return reduce(lambda x, y: x * 10 + y, \
# # # # # # # # # # # # #                   map(int, s.split('.')[0])) + \
# # # # # # # # # # # # #            reduce(lambda x, y: x / 10 + y, \
# # # # # # # # # # # # #                   map(int, s.split('.')[-1][::-1])) / 10
# # # # # # # # # # # # #
# # # # # # # # # # # # #
# # # # # # # # # # # # # print('str2float(\'123.456\') =', str2float('123.456'))
# # # # # # # # # # # # # if abs(str2float('123.456') - 123.456) < 0.00001:
# # # # # # # # # # # # #     print('测试成功!')
# # # # # # # # # # # # # else:
# # # # # # # # # # # # #     print('测试失败!')
# # # # # # # # # # # #
# # # # # # # # # # # #
# # # # # # # # # # # # def is_odd(n):
# # # # # # # # # # # #     return n % 2 == 1
# # # # # # # # # # # #
# # # # # # # # # # # #
# # # # # # # # # # # # # filter()函数用于过滤序列
# # # # # # # # # # # # # filter()函数也是用来接受两个参数，和map()函数一样是作用于
# # # # # # # # # # # # # 序列中的每个元素，但是根据返回的True和false来确定是否保留元素
# # # # # # # # # # # # print(list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15])))
# # # # # # # # # # # #
# # # # # # # # # # # #
# # # # # # # # # # # # # strip() 方法用于移除字符串头尾指定的字符（默认为空格)
# # # # # # # # # # # # def not_empty(s):
# # # # # # # # # # # #     return s and s.strip()
# # # # # # # # # # # #
# # # # # # # # # # # #
# # # # # # # # # # # # print(list(filter(not_empty, ['A', '', 'B', None, 'C', '  '])))
# # # # # # # # # # # #
# # # # # # # # # # # #
# # # # # # # # # # # # # 用filter求素数
# # # # # # # # # # # # def _odd_iter():
# # # # # # # # # # # #     n = 1
# # # # # # # # # # # #     while True:
# # # # # # # # # # # #         n = n + 2
# # # # # # # # # # # #         yield n
# # # # # # # # # # # #
# # # # # # # # # # # #
# # # # # # # # # # # # # 筛选序列
# # # # # # # # # # # # def _not_divisiable(n):
# # # # # # # # # # # #     return lambda x: x % n > 0
# # # # # # # # # # # #
# # # # # # # # # # # #
# # # # # # # # # # # # def primes():
# # # # # # # # # # # #     yield 2
# # # # # # # # # # # #     it = _odd_iter()  # 初始序列
# # # # # # # # # # # #     while True:
# # # # # # # # # # # #         n = next(it)  # 返回序列的第一个数
# # # # # # # # # # # #         yield n
# # # # # # # # # # # #         it = filter(_not_divisiable(n), it)
# # # # # # # # # # # #
# # # # # # # # # # # #
# # # # # # # # # # # # for n in primes():
# # # # # # # # # # # #     if n < 1000:
# # # # # # # # # # # #         pass
# # # # # # # # # # # #         # print(n)
# # # # # # # # # # # #     else:
# # # # # # # # # # # #         break
# # # # # # # # # # # #
# # # # # # # # # # # #
# # # # # # # # # # # # def is_palindrome(n):
# # # # # # # # # # # #     return str(n) == str(n)[::-1]
# # # # # # # # # # # #
# # # # # # # # # # # #
# # # # # # # # # # # # output = filter(is_palindrome, range(1, 1000))
# # # # # # # # # # # # print('1~1000:', list(output))
# # # # # # # # # # # # if list(filter(is_palindrome, range(1, 200))) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191]:
# # # # # # # # # # # #     print('测试成功!')
# # # # # # # # # # # # else:
# # # # # # # # # # # #     print('测试失败!')
# # # # # # # # # # #
# # # # # # # # # # #
# # # # # # # # # # # print(sorted([36, 5, -12, 9, -21]))
# # # # # # # # # # # # 接受一个key函数来实现自定义的排序，例如，按数值的绝对值大小排序
# # # # # # # # # # # print(sorted([36, 5, -12, 9, -21], key=abs))
# # # # # # # # # # # # 字符串的排序，根据ASCII码来排序的
# # # # # # # # # # # print(sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower))
# # # # # # # # # # # # 将上述函数进行反向排序
# # # # # # # # # # # print(sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True))
# # # # # # # # # # #
# # # # # # # # # # # # 对下列的学生分数，按姓名排序
# # # # # # # # # # # L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]
# # # # # # # # # # #
# # # # # # # # # # #
# # # # # # # # # # # def by_name(t):
# # # # # # # # # # #     # print('t = %s' % t[0])
# # # # # # # # # # #     return t[0]
# # # # # # # # # # #
# # # # # # # # # # #
# # # # # # # # # # # L2 = sorted(L, key=by_name)
# # # # # # # # # # # print(L2)
# # # # # # # # # # #
# # # # # # # # # # #
# # # # # # # # # # # # 按照成绩排序
# # # # # # # # # # # def by_score(t):
# # # # # # # # # # #     return t[1]
# # # # # # # # # # #
# # # # # # # # # # #
# # # # # # # # # # # L2 = sorted(L, key=by_score, reverse=True)
# # # # # # # # # # # print(L2)
# # # # # # # # # # #
# # # # # # # # # # #
# # # # # # # # # # #
# # # # # # # # # #
# # # # # # # # # #
# # # # # # # # # # def calc_sum(*args):
# # # # # # # # # #     ax = 0
# # # # # # # # # #     for n in args:
# # # # # # # # # #         ax = ax + n
# # # # # # # # # #     return ax
# # # # # # # # # #
# # # # # # # # # #
# # # # # # # # # # # 延时计算求和
# # # # # # # # # # def lazy_sum(*args):
# # # # # # # # # #     def sum():
# # # # # # # # # #         ax = 0
# # # # # # # # # #         for n in args:
# # # # # # # # # #             ax = ax + n
# # # # # # # # # #         return ax
# # # # # # # # # #     return sum
# # # # # # # # # #
# # # # # # # # # #
# # # # # # # # # # # 调用lazy_sum()，返回的不是求和结果，而是求和函数：
# # # # # # # # # # f = lazy_sum(1,3,5,7,9)
# # # # # # # # # # print(f)
# # # # # # # # # #
# # # # # # # # # # # 调用函数f时，才真正计算求和结果
# # # # # # # # # # print(f())
# # # # # # # # # #
# # # # # # # # # # # 当我们调用函数lazy_sum()时，每次都会返回一个新的函数，即使传入的参数是一致的
# # # # # # # # # # f1 = lazy_sum(1, 3, 5, 7, 9)
# # # # # # # # # # f2 = lazy_sum(1, 3, 5, 7, 9)
# # # # # # # # # # print(f1 == f2)
# # # # # # # # # #
# # # # # # # # # # # 闭包
# # # # # # # # # # def count():
# # # # # # # # # #     fs = []
# # # # # # # # # #     for i in range(1, 4):
# # # # # # # # # #         def f():
# # # # # # # # # #             return i*i
# # # # # # # # # #         fs.append(f)
# # # # # # # # # #     return fs
# # # # # # # # # #
# # # # # # # # # #
# # # # # # # # # # f1, f2, f3 = count()
# # # # # # # # # #
# # # # # # # # # # # 此处的打印结果都为9，与想要的结果不符
# # # # # # # # # # # 原因在于函数引用的i，并非立刻执行的。三个函数都返回时，引用的i变为3，因此最终结果为9
# # # # # # # # # # # 所以返回闭包时：返回函数不要引用任何循环变量，或者后续会发生变化的变量
# # # # # # # # # # print(f1())
# # # # # # # # # # print(f2())
# # # # # # # # # # print(f3())
# # # # # # # # # #
# # # # # # # # # #
# # # # # # # # # # # 此函数的正确写法应为
# # # # # # # # # # # def count():
# # # # # # # # # # #     def f(j):
# # # # # # # # # # #         def g():
# # # # # # # # # # #             return j*j
# # # # # # # # # # #         return g
# # # # # # # # # # #     fs = []
# # # # # # # # # # #     for i in range(1, 4):
# # # # # # # # # # #         fs.append(f(i))
# # # # # # # # # # #     return fs
# # # # # # # # # #
# # # # # # # # # #
# # # # # # # # # # def count():
# # # # # # # # # #     def f(j):
# # # # # # # # # #         def g():
# # # # # # # # # #             return j * j
# # # # # # # # # #         return g
# # # # # # # # # #     fs = []
# # # # # # # # # #     for i in range(1, 4):
# # # # # # # # # #         fs.append(f(i))
# # # # # # # # # #     return fs
# # # # # # # # # #
# # # # # # # # # #
# # # # # # # # # # f1, f2, f3 = count()
# # # # # # # # # # print(f1())
# # # # # # # # # # print(f2())
# # # # # # # # # # print(f3())
# # # # # # # # # #
# # # # # # # # #
# # # # # # # # #
# # # # # # # # # a = list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
# # # # # # # # # print(a)
# # # # # # # # # # 关键字lambda标识匿名函数，冒号前边的x表示函数的参数
# # # # # # # # # # 匿名函数的限制：只能有一个表达式。不用写return，返回值就是表达式的结果
# # # # # # # # # # 匿名函数的好处：不用担心函数名冲突问题
# # # # # # # # # # 匿名函数也是一个函数对象，可以赋值给一个变量，在利用变量来调用该函数
# # # # # # # # # f = lambda x: x * x
# # # # # # # # # print(f(5))
# # # # # # # # #
# # # # # # # # #
# # # # # # # # # # 匿名函数也可作为返回值
# # # # # # # # # def build(x, y):
# # # # # # # # #     return lambda: x * x + y * y
# # # # # # # # #
# # # # # # # # #
# # # # # # # # # # 过滤1-20之间的奇数
# # # # # # # # # L = list(filter(lambda n: n % 2 == 1, range(1, 20)))
# # # # # # # # # print(L)
# # # # # # # # #
# # # # # # # # #
# # # # # # # # # # 装饰器
# # # # # # # # # def now():
# # # # # # # # #     print('2015-3-25')
# # # # # # # # #
# # # # # # # # #
# # # # # # # # # f = now
# # # # # # # # # f()
# # # # # # # # #
# # # # # # # # # # 取到函数名
# # # # # # # # # print(now.__name__)
# # # # # # # # # print(f.__name__)
# # # # # # # # #
# # # # # # # # #
# # # # # # # # # # 假设我们要增强now()函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改函数定义
# # # # # # # # # # 这种在代码运行期间动态增加的方式，称之为"装饰器"（Decorator）
# # # # # # # # #
# # # # # # # # # # 本质上decorator就是一个返回函数的高阶函数
# # # # # # # # # # 定义一个能打印日志的decorator
# # # # # # # # # def log(func):
# # # # # # # # #     def wrapper(*args, **kw):
# # # # # # # # #         print('call %s():' % func.__name__)
# # # # # # # # #         return func(*args, **kw)
# # # # # # # # #
# # # # # # # # #     return wrapper
# # # # # # # # #
# # # # # # # # #
# # # # # # # # # # 观察上边的Log，因为decorator，所以接受一个函数作为参数，并返回一个函数
# # # # # # # # # # 借助Python的@语法，把decorator置于函数的定义处
# # # # # # # # # @log
# # # # # # # # # def now():
# # # # # # # # #     print('2015-3-25')
# # # # # # # # #
# # # # # # # # #
# # # # # # # # # # 调用now()函数，不仅会运行函数的本身，还会在运行now()函数前打印一行日志
# # # # # # # # # now()
# # # # # # # # #
# # # # # # # # #
# # # # # # # # # # 由于log()是一个decorator，返回一个函数，所以，原来的now()函数依然存在，只是现在
# # # # # # # # # # 同名的now变量指向了新函数，于是调用now()将执行新函数，即在log()函数中返回wrapper()函数
# # # # # # # # # # wrapper()函数的参数定义是(*args, **kw),因此，wrapper()函数可以接受任意参数调用
# # # # # # # # # # 首先打印日志，再紧接着调用原始函数
# # # # # # # # #
# # # # # # # # #
# # # # # # # # # # 如果decorator本身需要传入参数，那就编写一个返回decorator的高阶函数
# # # # # # # # # def log(text):
# # # # # # # # #     def decorator(func):
# # # # # # # # #         def wrapper(*args, **kw):
# # # # # # # # #             print('%s %s():' % (text, func.__name__))
# # # # # # # # #             return func(*args, **kw)
# # # # # # # # #
# # # # # # # # #         return wrapper
# # # # # # # # #
# # # # # # # # #     return decorator
# # # # # # # # #
# # # # # # # # #
# # # # # # # # # @log('execute')
# # # # # # # # # def now():
# # # # # # # # #     print('2018-05-14')
# # # # # # # # #
# # # # # # # # #
# # # # # # # # # now()
# # # # # # # # # # 经过decorator装饰之后的函数，__name__变为了'wrapper'
# # # # # # # # # print(now.__name__)
# # # # # # # # #
# # # # # # # # # # 所以一个完整的decorator函数，编写如下
# # # # # # # # # import functools
# # # # # # # # #
# # # # # # # # #
# # # # # # # # # def log(func):
# # # # # # # # #     @functools.wraps(func)
# # # # # # # # #     def wrapper(*args, **kw):
# # # # # # # # #         print('call %s():' % func.__name__)
# # # # # # # # #         return func(*args, **kw)
# # # # # # # # #
# # # # # # # # #     return wrapper
# # # # # # # # #
# # # # # # # # #
# # # # # # # # # @log
# # # # # # # # # def now():
# # # # # # # # #     print('2018-05-21')
# # # # # # # # #
# # # # # # # # #
# # # # # # # # # now()
# # # # # # # # # print(now.__name__)
# # # # # # # # #
# # # # # # # # #
# # # # # # # # # # 带参数的decorator
# # # # # # # # # def log1(text):
# # # # # # # # #     def decorator(func):
# # # # # # # # #         @functools.wraps(func)
# # # # # # # # #         def wrapper(*args, **kw):
# # # # # # # # #             print('%s %s():' % (text, func.__name__))
# # # # # # # # #             return func(*args, **kw)
# # # # # # # # #
# # # # # # # # #         return wrapper
# # # # # # # # #
# # # # # # # # #     return decorator
# # # # # # # # #
# # # # # # # # #
# # # # # # # # # @log1('test')
# # # # # # # # # def now():
# # # # # # # # #     print('2018-05-21')
# # # # # # # # #
# # # # # # # # #
# # # # # # # # # now()
# # # # # # # # # print(now.__name__)
# # # # # # # # #
# # # # # # # # # import time, functools
# # # # # # # # #
# # # # # # # # #
# # # # # # # # # def metric(fn):
# # # # # # # # #     @functools.wraps(fn)
# # # # # # # # #     def wrapper(*args, **kw):
# # # # # # # # #         start = time.time()
# # # # # # # # #         result = fn(*args, **kw)
# # # # # # # # #         ellipsed = time.time() - start
# # # # # # # # #         print('%s executed in %s ms' % (fn.__name__, 1000 * ellipsed))
# # # # # # # # #         return result
# # # # # # # # #     return wrapper
# # # # # # # # #
# # # # # # # # #
# # # # # # # # # # 测试
# # # # # # # # # @metric
# # # # # # # # # def fast(x, y):
# # # # # # # # #     time.sleep(0.0012)
# # # # # # # # #     return x + y
# # # # # # # # #
# # # # # # # # #
# # # # # # # # # @metric
# # # # # # # # # def slow(x, y, z):
# # # # # # # # #     time.sleep(0.1234)
# # # # # # # # #     return x * y * z
# # # # # # # # #
# # # # # # # # #
# # # # # # # # # f = fast(11, 22)
# # # # # # # # # s = slow(11, 22, 33)
# # # # # # # # # print(time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()))
# # # # # # # # # if f != 33:
# # # # # # # # #     print('测试失败!')
# # # # # # # # # elif s != 7986:
# # # # # # # # #     print('测试失败!')
# # # # # # # # # else:
# # # # # # # # #     print('测试成功')
# # # # # # # #
# # # # # # # #
# # # # # # # # def int2(x, base=2):
# # # # # # # #     return int(x, base)
# # # # # # # #
# # # # # # # #
# # # # # # # # # int()函数提供额外参数，base将任意数字转换为任意进制的数字
# # # # # # # # print(int2('1000000'))
# # # # # # # # print(int2('1010101'))
# # # # # # # #
# # # # # # # # # 创建一个偏函数
# # # # # # # # # functools.partial的作用是：把一个函数的某些参数固定(设置默认值),返回一个新函数，简化调用
# # # # # # # # import functools
# # # # # # # #
# # # # # # # # int2 = functools.partial(int, base=2)
# # # # # # # #
# # # # # # # # print(int2('100000'))
# # # # # # # #
# # # # # # # # # 创建偏函数时，也可以接受函数对象、*args和**kw
# # # # # # # # kw = {'base': 2}
# # # # # # # # print(int('10101', **kw))
# # # # # # # # # 传入函数,会把10作为*args的一部分自动添加到左边
# # # # # # # # # 即max2(2, 5, 7)实际上是max2(10, 2, 5, 7)，打印结果为10
# # # # # # # # max2 = functools.partial(max, 10)
# # # # # # # # print(max2(2, 5, 7))
# # # # # # # #
# # # # # # # # # 当函数的参数个数太多，需要简化时，使用functools.partial可以创建一个新的函数，
# # # # # # # # # 这个新函数可以固定住原函数的部分参数，从而在调用时更简单。
# # # # # # # #
# # # # # # # #
# # # # # # #
# # # # # # #
# # # # # # # __author__ = 'Bike'
# # # # # # #
# # # # # # # import sys
# # # # # # #
# # # # # # #
# # # # # # # # 内建sys模块为例，编写一个hello的模块
# # # # # # # def test():
# # # # # # #     args = sys.argv
# # # # # # #     if len(args) == 1:
# # # # # # #         print('Hello world!')
# # # # # # #     elif len(args) == 2:
# # # # # # #         print('Hello, %s!' % args[1])
# # # # # # #     else:
# # # # # # #         print('Too many arguments!')
# # # # # # #
# # # # # # #
# # # # # # # if __name__ == '__main__':
# # # # # # #     test()
# # # # # # #
# # # # # # #
# # # # # # # # 正常的函数和变量名是公开的的，可以直接被引用
# # # # # # # # 类似于_abc这样的变量是私有的，不能被直接调用
# # # # # # # # 私有函数或变量的用法
# # # # # # # def _private_1(name):
# # # # # # #     return 'Hello, %s' % name
# # # # # # #
# # # # # # #
# # # # # # # def _private_2(name):
# # # # # # #     return 'Hi, %s' % name
# # # # # # #
# # # # # # #
# # # # # # # def greeting(name):
# # # # # # #     if len(name) > 3:
# # # # # # #         return _private_1(name)
# # # # # # #     else:
# # # # # # #         return _private_2(name)
# # # # # # #
# # # # # # #
# # # # # # # # 在模块里公开greeting()函数，把内部逻辑用private隐藏起来
# # # # # # # print(greeting('lucy'))
# # # # # # # print(greeting('li'))
# # # # # # #
# # # # # # #
# # # # # # # # 类和实例
# # # # # # # class Student(object):
# # # # # # #     pass
# # # # # # #
# # # # # # #
# # # # # # # # 创建实例
# # # # # # # bart = Student()
# # # # # # # print(bart)
# # # # # # # print(Student)
# # # # # # #
# # # # # # # # 可以自由的给一个实例变量绑定属性
# # # # # # # bart.name = 'bart Simposon'
# # # # # # # print(bart.name)
# # # # # # #
# # # # # # #
# # # # # # # # 由于类起到模板作用，所以，在创建实例的时候，把一些属性强制填写进去
# # # # # # # # 通过__init__方法，在创建实例的时候，把name，socre等属性绑定上去
# # # # # # # # __init__的第一个参数永远是self，表示创建的实例本身
# # # # # # # class Student(object):
# # # # # # #
# # # # # # #     def __init__(self, name, score):
# # # # # # #         self.name = name
# # # # # # #         self.score = score
# # # # # # #
# # # # # # #
# # # # # # # # 有了init方法，在创建实例的时候，就不能传入为空的参数，传入的参数必须与init中匹配
# # # # # # # # self可以不用传入
# # # # # # # bart = Student('mike', 60)
# # # # # # # print(bart.name)
# # # # # # # print(bart.score)
# # # # # # #
# # # # # # #
# # # # # # # # 数据的封装
# # # # # # # def print_score(std):
# # # # # # #     print('%s: %s' % (std.name, std.score))
# # # # # # #
# # # # # # #
# # # # # # # print_score(bart)
# # # # # # #
# # # # # # #
# # # # # # # # 定义类的方法
# # # # # # # class Student(object):
# # # # # # #
# # # # # # #     def __init__(self, name, score):
# # # # # # #         self.name = name
# # # # # # #         self.score = score
# # # # # # #
# # # # # # #     def print_score(self):
# # # # # # #         print('%s: %s' % (self.name, self.score))
# # # # # # #
# # # # # # #     # 数据封装的另一个好处是可以给Student增加新方法
# # # # # # #     def get_grade(self):
# # # # # # #         if self.score >= 90:
# # # # # # #             return 'A'
# # # # # # #         elif self.score >= 60:
# # # # # # #             return 'B'
# # # # # # #         else:
# # # # # # #             return 'C'
# # # # # # #
# # # # # # #
# # # # # # # bart = Student('lucy', 80)
# # # # # # # bart.print_score()
# # # # # # # print(bart.name, bart.get_grade())
# # # # # # #
# # # # # # # # 访问限制
# # # # # # # # 此处实例的score属性被修改
# # # # # # # bart.score = 99
# # # # # # # print(bart.score)
# # # # # # #
# # # # # # #
# # # # # # # # 如果不想让属性被修改，在属性前边加上两个下划线__，即变成了私有变量
# # # # # # # # 只有内部可以访问，外部不能访问
# # # # # # # class Student(object):
# # # # # # #
# # # # # # #     def __init__(self, name, score):
# # # # # # #         self.__name = name
# # # # # # #         self.__score = score
# # # # # # #
# # # # # # #     def print_score(self):
# # # # # # #         print('%s: %s' % (self.__name, self.__score))
# # # # # # #
# # # # # # #     # 外部获取属性的方法
# # # # # # #     def get_name(self):
# # # # # # #         return self.__name
# # # # # # #
# # # # # # #     def get_score(self):
# # # # # # #         return self.__score
# # # # # # #
# # # # # # #     # 允许外界修改类的属性
# # # # # # #     # 将类的属性设置为私有的，通过set，get方法可以对参数进行检验，避免无效的参数
# # # # # # #     def set_score(self, score):
# # # # # # #         if 0 <= score <= 100:
# # # # # # #             self.__score = score
# # # # # # #         else:
# # # # # # #             raise ValueError('bad score')
# # # # # # #
# # # # # # #
# # # # # # # bart = Student('kirk', 78)
# # # # # # # bart.print_score()
# # # # # # # # 此时已经不能再调用类的属性
# # # # # # # # print(bart.__name)
# # # # # # # # 利用类方法调用访问类的属性
# # # # # # # print(bart.get_name())
# # # # # # # # 利用类的方法修改类的属性
# # # # # # # bart.set_score(66)
# # # # # # # print(bart.get_score())
# # # # # # # # 此处传入的分数超过100，引起报错
# # # # # # # # print(bart.set_score(109))
# # # # # # #
# # # # # # # # 变量名__xxx__，是特殊变量可以直接访问，所以，不能定义__name__，__socre__这样的变量
# # # # # # # # 有些时候，你会看到以一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的
# # # # # # # # 但是，按照约定俗成的规定，当你看到这样的变量时
# # # # # # # # 意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”
# # # # # # #
# # # # # # # # __name也可以从外部获取到值
# # # # # # # # 不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，
# # # # # # # # 所以，仍然可以通过_Student__name来访问__name变量
# # # # # # #
# # # # # # # # 但是强烈建议你不要这么干，因为不同版本的Python解释器可能会把__name改成不同的变量名。
# # # # # # # print(bart._Student__name)
# # # # # # #
# # # # # # #
# # # # # # # # 作业
# # # # # # # # 请把下面的Student对象的gender字段对外隐藏起来
# # # # # # # # 用get_gender()和set_gender()代替，并检查参数有效性
# # # # # # # class Student(object):
# # # # # # #     def __init__(self, name, gender):
# # # # # # #         self.name = name
# # # # # # #         self.__gender = gender
# # # # # # #
# # # # # # #     def get_gender(self):
# # # # # # #         return self.__gender
# # # # # # #
# # # # # # #     def set_gender(self, gender):
# # # # # # #         if gender == 'male' or gender == 'female':
# # # # # # #             self.__gender = gender
# # # # # # #         else:
# # # # # # #             raise ValueError('bad score')
# # # # # # #
# # # # # # #
# # # # # # # # 测试:
# # # # # # # bart = Student('Bart', 'male')
# # # # # # # if bart.get_gender() != 'male':
# # # # # # #     print('测试失败!')
# # # # # # # else:
# # # # # # #     bart.set_gender('female')
# # # # # # #     if bart.get_gender() != 'female':
# # # # # # #         print('测试失败!')
# # # # # # #     else:
# # # # # # #         print('测试成功!')
# # # # # # #
# # # # # # #
# # # # # # # # 继承和多态
# # # # # # # # 定义一个animal类
# # # # # # # class Animal(object):
# # # # # # #
# # # # # # #     def run(self):
# # # # # # #         print('Animal is running...')
# # # # # # #
# # # # # # #
# # # # # # # # 写dog，cat类继承与Animal类
# # # # # # # class Dog(Animal):
# # # # # # #     pass
# # # # # # #
# # # # # # #
# # # # # # # class Cat(Animal):
# # # # # # #     pass
# # # # # # #
# # # # # # #
# # # # # # # # 试运行子类
# # # # # # # dog = Dog()
# # # # # # # dog.run()
# # # # # # #
# # # # # # #
# # # # # # # # 增加子类方法
# # # # # # # class Dog(Animal):
# # # # # # #
# # # # # # #     def run(self):
# # # # # # #         print('Dog is running...')
# # # # # # #
# # # # # # #     def eat(self):
# # # # # # #         print('Eating meat...')
# # # # # # #
# # # # # # #
# # # # # # # # 子类的方法会覆盖父类的方法
# # # # # # # # 在代码运行的时候，总是会调用子类的run()。这样，我们就获得了继承的另一个好处：多态
# # # # # # # dog = Dog()
# # # # # # # dog.run()
# # # # # # # dog.eat()
# # # # # # #
# # # # # # # # 判断变量是否归属于某个类型
# # # # # # # a = list()
# # # # # # # b = Animal()
# # # # # # # c = Dog()
# # # # # # #
# # # # # # # print(isinstance(c, Dog))
# # # # # # # print(isinstance(c, list))
# # # # # # # # 子类的变量也可以归于父类
# # # # # # # print(isinstance(c, Animal))
# # # # # # #
# # # # # # #
# # # # # # # # 对于Python这样的动态语言来说，
# # # # # # # # 则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了：
# # # # # # # class Student():
# # # # # # #     def grade(self):
# # # # # # #         print('哇要考试啦！')
# # # # # # #
# # # # # # #
# # # # # # # class goodStudent(Student):
# # # # # # #     def grade(self):
# # # # # # #         print('哇满分！')
# # # # # # #
# # # # # # #
# # # # # # # class badStudent(Student):
# # # # # # #     def grade(self):
# # # # # # #         print('哇零分')
# # # # # # #
# # # # # # #
# # # # # # # class Pig():
# # # # # # #     def grade(self):
# # # # # # #         print('精品猪肉！')
# # # # # # #
# # # # # # #
# # # # # # # def kind(student):
# # # # # # #     student.grade()
# # # # # # #
# # # # # # #
# # # # # # # student = Student()
# # # # # # # good = goodStudent()
# # # # # # # bad = badStudent()
# # # # # # # pig = Pig()
# # # # # # # kind(student)
# # # # # # # kind(good)
# # # # # # # kind(bad)
# # # # # # # kind(pig)
# # # # # # #
# # # # # # #
# # # # # # #
# # # # # #
# # # # # #
# # # # # # print(type('123'))
# # # # # # # 获取对象信息
# # # # # # # 判断对象的类型
# # # # # #
# # # # # # # 如果一个变量指向函数或者类，也可以用type()判断
# # # # # # print(type(abs))
# # # # # #
# # # # # # # 可以判断两个变量的类型是否相同
# # # # # # print(type(123) == type(456))
# # # # # #
# # # # # # # 判断一个对象是否是函数
# # # # # # import types
# # # # # #
# # # # # #
# # # # # # def fn():
# # # # # #     pass
# # # # # #
# # # # # #
# # # # # # print(type(fn) == types.FunctionType)
# # # # # # print(type(abs) == types.BuiltinFunctionType)
# # # # # # print(type(lambda x: x) == types.LambdaType)
# # # # # # print(type((x for x in range(10))) == types.GeneratorType)
# # # # # #
# # # # # # # 使用instance来判断类型
# # # # # # print(isinstance('a', str))
# # # # # # print(isinstance(123, float))
# # # # # # # 判断一个变量是否是某些类型中的一种
# # # # # # # 总是优先使用isinstance()判断类型，可以将指定类型及其子类“一网打尽”
# # # # # # print(isinstance([1, 2, 3], (list, tuple)))
# # # # # #
# # # # # # # 使用dir()
# # # # # # # 如果要获得一个对象的所有属性和方法，使用dir()
# # # # # # # 它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法
# # # # # # # print(dir('qwer'))
# # # # # #
# # # # # # # 系统的len()函数等价于下面的函数
# # # # # # print(len('abc'))
# # # # # # print('abc'.__len__())
# # # # # #
# # # # # #
# # # # # # # 所以可以自己定义系统方法
# # # # # # class MyDog(object):
# # # # # #     def __len__(self):
# # # # # #         return 100
# # # # # #
# # # # # #
# # # # # # dog = MyDog()
# # # # # # print(len(dog))
# # # # # #
# # # # # # # 普通属性或方法
# # # # # # print('ABC'.lower())
# # # # # #
# # # # # #
# # # # # # # 配合getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态
# # # # # # class MyObject(object):
# # # # # #     def __init__(self):
# # # # # #         self.x = 9
# # # # # #
# # # # # #     def power(self):
# # # # # #         return self.x * self.x
# # # # # #
# # # # # #
# # # # # # obj = MyObject()
# # # # # #
# # # # # # # 测试该对象的属性
# # # # # # # 是否具有属性x
# # # # # # print(hasattr(obj, 'x'))
# # # # # # # 打印属性的值
# # # # # # print(obj.x)
# # # # # # # 添加一个属性y
# # # # # # setattr(obj, 'y', 19)
# # # # # # # 获取新添加的属性
# # # # # # print(getattr(obj, 'y'))
# # # # # # # 打印新添加的属性
# # # # # # print(obj.y)
# # # # # # # 设置不存在的属相报错显示，z不存在，报错404
# # # # # # print(obj, 'z', 404)
# # # # # # # 获取对象的方法
# # # # # # print(hasattr(obj, 'power'))
# # # # # # # 获取属性power
# # # # # # print(obj, 'power')
# # # # # # # 获取属性power并赋值到变量fn
# # # # # # fn = getattr(obj, 'power')
# # # # # # print(fn)
# # # # # # # 调用fn
# # # # # # print(fn())
# # # # # #
# # # # # #
# # # # # # # 实例类和类属性
# # # # # # # 由于Python是动态语言，根据类的创建的实例可以任意绑定属性
# # # # # # class Student(object):
# # # # # #     def __init__(self, name):
# # # # # #         self.name = name
# # # # # #
# # # # # #
# # # # # # s = Student('Bob')
# # # # # # # 添加一个score属性
# # # # # # s.score = 90
# # # # # # print(s.score)
# # # # # #
# # # # # #
# # # # # # # name是类属性，归Student所有
# # # # # # class Student(object):
# # # # # #     name = 'Student'
# # # # # #
# # # # # #
# # # # # # # 类的所有实例都可以访问这个归属属性
# # # # # # s = Student()
# # # # # # # 使用实例来访问属性
# # # # # # print(s.name)
# # # # # # # 使用类来访问属性
# # # # # # print(Student.name)
# # # # # # # 给实例绑定属性
# # # # # # s.name = 'mike'
# # # # # # # 实例属性优先级比类属性高，屏蔽了类的name属性
# # # # # # print(s.name)
# # # # # # # 但是类的属性未消失
# # # # # # print(Student.name)
# # # # # # # 删除实例的属性,类的属性也可被删除
# # # # # # del s.name
# # # # # # # del Student.name
# # # # # # print(s.name)
# # # # # #
# # # # # #
# # # # # # class Student(object):
# # # # # #     count = 0
# # # # # #
# # # # # #     def __init__(self, name):
# # # # # #         self.name = name
# # # # # #         Student.count += 1
# # # # # #
# # # # # #
# # # # # # # 测试:
# # # # # # if Student.count != 0:
# # # # # #     print('测试失败!')
# # # # # # else:
# # # # # #     bart = Student('Bart')
# # # # # #     if Student.count != 1:
# # # # # #         print('测试失败!')
# # # # # #     else:
# # # # # #         lisa = Student('Bart')
# # # # # #         if Student.count != 2:
# # # # # #             print('测试失败!')
# # # # # #         else:
# # # # # #             print('Students:', Student.count)
# # # # # #             print('测试通过!')
# # # # # #
# # # # # #
# # # # #
# # # # # # class Student(object):
# # # # # #     pass
# # # # # #
# # # # # #
# # # # # # # 使用__slots__
# # # # # # s = Student()
# # # # # # # 绑定一个实例属性
# # # # # # s.age = 10
# # # # # # print(s.age)
# # # # # #
# # # # # #
# # # # # # # 给实例绑定一个方法
# # # # # # def set_age(self, age):
# # # # # #     self.age = age
# # # # # #
# # # # # #
# # # # # # from types import MethodType
# # # # # #
# # # # # # # 给实例绑定一个方法
# # # # # # s.set_age = MethodType(set_age, s)
# # # # # # s.set_age(12)
# # # # # # print(s.age)
# # # # # #
# # # # # # # 对实例绑定的方法在另一个新建的实例上不起作用
# # # # # # s2 = Student()
# # # # # #
# # # # # #
# # # # # # # s2.set_age(13)
# # # # # #
# # # # # #
# # # # # # # 但是在类中定义方法，可以让所有的实例都绑定上
# # # # # # def set_score(self, score):
# # # # # #     self.score = score
# # # # # #
# # # # # #
# # # # # # # 类方法绑定
# # # # # # Student.set_score = set_score
# # # # # # # 调用类的方法
# # # # # # s2.set_score(100)
# # # # # # print(s2.score)
# # # # # #
# # # # # #
# # # # # # # 通过使用__slots__来限制实例类的属性
# # # # # # # 只允许Student添加name和score
# # # # # # class Student(object):
# # # # # #     __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称
# # # # # #
# # # # # #
# # # # # # # 创建新的实例
# # # # # # s = Student()
# # # # # # # 绑定属性
# # # # # # s.name = 'mike'
# # # # # # s.age = 12
# # # # # # # 绑定额外的score属性,score没在tuple中，所以会报错
# # # # # # # s.score = 100
# # # # # #
# # # # # #
# # # # # # # 使用__slots__要注意，__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的：
# # # # # # class GraduateStudent(Student):
# # # # # #     pass
# # # # # #
# # # # # #
# # # # # # g = GraduateStudent()
# # # # # # g.score = 100
# # # # #
# # # # #
# # # # # class Student(object):
# # # # #
# # # # #     # 使用@property，把一个方法变成属性来调用
# # # # #     @property
# # # # #     def score(self):
# # # # #         return self._score
# # # # #
# # # # #     @score.setter
# # # # #     def score(self, value):
# # # # #         if not isinstance(value, int):
# # # # #             raise ValueError('score must be an integer!')
# # # # #         if value < 0 or value > 100:
# # # # #             raise ValueError('score must be between 0 ~ 100!')
# # # # #         self._score = value
# # # # #
# # # # #
# # # # # s = Student()
# # # # # s.score = 60  # 实际转化为s.set_score(60)
# # # # # print(s.score)  # 实际转化为s.get_score()
# # # # #
# # # # #
# # # # # # s.score = 9999  # 传入的参数超出界定的范围
# # # # #
# # # # #
# # # # # # 设置只读属性
# # # # # class Student(object):
# # # # #
# # # # #     @property  # 只加@property的话，相当只设置了属性的getter方法，即已读属性
# # # # #     def birth(self):
# # # # #         return self._birth
# # # # #
# # # # #     @birth.setter  # 添加setter属性，操作属性
# # # # #     def birth(self, value):
# # # # #         self._birth = value
# # # # #
# # # # #     @property
# # # # #     def age(self):
# # # # #         return 2015 - self._birth
# # # # #
# # # # #
# # # # # # 请利用@property给一个Screen对象加上width和height属性，以及一个只读属性resolution：
# # # # # class Screen(object):
# # # # #
# # # # #     @property
# # # # #     def width(self):
# # # # #         return self._width
# # # # #
# # # # #     @width.setter
# # # # #     def width(self, value):
# # # # #         self._width = value
# # # # #
# # # # #     @property
# # # # #     def height(self):
# # # # #         return self._height
# # # # #
# # # # #     @height.setter
# # # # #     def height(self, value):
# # # # #         self._height = value
# # # # #
# # # # #     @property
# # # # #     def resolution(self):
# # # # #         return self._width * self._height
# # # # #
# # # # #
# # # # # # 测试:
# # # # # s = Screen()
# # # # # s.width = 1024
# # # # # s.height = 768
# # # # # print('resolution =', s.resolution)
# # # # # if s.resolution == 786432:
# # # # #     print('测试通过!')
# # # # # else:
# # # # #     print('测试失败!')
# # # # #
# # # # #
# # # # # # 多重继承
# # # # # class Animal(object):
# # # # #     pass
# # # # #
# # # # #
# # # # # # 大类,Mammal:哺乳动物
# # # # # class Mammal(Animal):
# # # # #     pass
# # # # #
# # # # #
# # # # # class Bird(Animal):
# # # # #     pass
# # # # #
# # # # #
# # # # # # 各种动物
# # # # # class Dog(Mammal):
# # # # #     pass
# # # # #
# # # # #
# # # # # class Bat(Mammal):
# # # # #     pass
# # # # #
# # # # #
# # # # # # 鹦鹉
# # # # # class Parrot(Bird):
# # # # #     pass
# # # # #
# # # # #
# # # # # # 鸵鸟
# # # # # class Ostrich(Bird):
# # # # #     pass
# # # # #
# # # # #
# # # # # # 加上Runnable和Flyable
# # # # # class Runnable(object):
# # # # #     def run(self):
# # # # #         print('Running...')
# # # # #
# # # # #
# # # # # class Flyable(object):
# # # # #     def fly(self):
# # # # #         print('Flying...')
# # # # #
# # # # #
# # # # # # 需要runnable功能的动物，多继承一个Runnable
# # # # # class Dog(Mammal, Runnable):
# # # # #     pass
# # # # #
# # # # #
# # # # # # 通过多重继承，一个子类就能获取多个父类的所有功能
# # # # #
# # # # # # MixIn：通常，主线都是单一继承下来的，例如，Ostrich继承自Bird。\
# # # # # # 但是，如果需要“混入”额外的功能，通过多重继承就可以实现，\
# # # # # # 比如，让Ostrich除了继承自Bird外，再同时继承Runnable
# # # # # # 这种设计通常称之为MixIn
# # # # #
# # # # # # Python自带的很多库也使用了MixIn。\
# # # # # # 举个例子，Python自带了TCPServer和UDPServer这两类网络服务，\
# # # # # # 而要同时服务多个用户就必须使用多进程或多线程模型，\
# # # # # # 这两种模型由ForkingMixIn和ThreadingMixIn提供。\
# # # # # # 通过组合，我们就可以创造出合适的服务来。
# # # # #
# # # # # # 例如编写一个多进程的TCP服务
# # # # # # class MyTCPServer(TCPServer, ForkingMixIn):
# # # # # #     pass
# # # # #
# # # # #
# # # # # # 定制类：
# # # # # class Student(object):
# # # # #     def __init__(self, name):
# # # # #         self.name = name
# # # # #
# # # # #
# # # # # print(Student('mike'))
# # # # #
# # # # #
# # # # # # 利用__str__来返回一个规定字符串
# # # # # class Student(object):
# # # # #     def __init__(self, name):
# # # # #         self.name = name
# # # # #
# # # # #     def __str__(self):
# # # # #         return 'Student object (name: %s)' % self.name
# # # # #
# # # # #
# # # # # print(Student('bob'))
# # # # # s = Student('jack')
# # # # # print(s)
# # # # #
# # # # #
# # # # # # __iter__：类似于循环for...in
# # # # # class Fib(object):
# # # # #     def __init__(self):
# # # # #         self.a, self.b = 0, 1  # 初始化两个计数器a，b
# # # # #
# # # # #     def __iter__(self):
# # # # #         return self  # 实例本身就是迭代对象，故返回自己
# # # # #
# # # # #     def __next__(self):
# # # # #         self.a, self.b = self.b, self.a + self.b  # 计算下一个值
# # # # #         if self.a > 100000:  # 设置退出循环条件
# # # # #             raise StopIteration()
# # # # #         return self.a
# # # # #
# # # # #
# # # # # for n in Fib():
# # # # #     print(n)
# # # # #
# # # # #
# # # # # # __getitem__: 取出__iter__中的元素
# # # # # class Fib(object):
# # # # #     def __getitem__(self, n):
# # # # #         a, b = 1, 1
# # # # #         for x in range(n):
# # # # #             a, b = b, a + b
# # # # #         return a
# # # # #
# # # # #
# # # # # # 取出任一特定的元素
# # # # # f = Fib()
# # # # # print(f[0])
# # # # # print(f[3])
# # # # #
# # # # #
# # # # # # 但是这个方法不能进行切片操作，想要进行进行切片需要进一步完善功能
# # # # # class Fib(object):
# # # # #     def __getitem__(self, n):
# # # # #         if isinstance(n, int):  # n是索引
# # # # #             a, b = 1, 1
# # # # #             for x in range(n):
# # # # #                 a, b = b, a + b
# # # # #             return a
# # # # #         if isinstance(n, slice):  # n是切片
# # # # #             start = n.start
# # # # #             stop = n.stop
# # # # #             if start is None:
# # # # #                 start = 0
# # # # #             a, b = 1, 1
# # # # #             L = []
# # # # #             for x in range(stop):
# # # # #                 if x >= start:
# # # # #                     L.append(a)
# # # # #                 a, b = b, a + b
# # # # #             return L
# # # # #
# # # # #
# # # # # # 实验Fib的切片
# # # # # f = Fib()
# # # # # print(f[0:5])
# # # # #
# # # # #
# # # # # # 此方法没有对负数做处理。所以，实现一个__getitem__需要做很多的工作
# # # # # # 与之对应的是__setitem__()方法，把对象视作list或dict来对集合赋值\
# # # # # # 最后，还有一个__delitem__()方法，用于删除某个元素。
# # # # #
# # # # #
# # # # # # __getattr__：使用此属性，动态返回一个属性
# # # # # class Student(object):
# # # # #
# # # # #     def __init__(self):
# # # # #         self.name = 'mike'
# # # # #
# # # # #
# # # # # # 调用不存在的score，此时就会报错
# # # # # s = Student()
# # # # # # 调用name属性
# # # # # print(s.name)
# # # # #
# # # # #
# # # # # # 调用不存在的score属性
# # # # # # print(s.score)
# # # # #
# # # # # # 动态返回属性
# # # # # class Student(object):
# # # # #
# # # # #     def __init__(self):
# # # # #         self.name = 'Bob'
# # # # #
# # # # #     def __getattr__(self, item):
# # # # #         if item == 'score':
# # # # #             return 99
# # # # #
# # # # #
# # # # # s = Student()
# # # # # print(s.score)
# # # # #
# # # # #
# # # # # # 也可返回一个函数
# # # # # class Student(object):
# # # # #
# # # # #     def __getattr__(self, item):
# # # # #         if item == 'age':
# # # # #             return lambda: 25
# # # # #
# # # # #
# # # # # s = Student()
# # # # # print(s.age())
# # # # #
# # # # # # 在没有找到属性的情况下，才会从__getattr__中寻找，例如，name已有属性，不会寻找
# # # # #
# # # # #
# # # # # # 此外，注意到任意调用如s.abc都会返回None，这是因为我们定义的__getattr__默认返回就是None。\
# # # # # # 要让class只响应特定的几个属性，我们就要按照约定，抛出AttributeError的错误：
# # # # # class Student(object):
# # # # #
# # # # #     def __getattr__(self, item):
# # # # #         if item == 'age':
# # # # #             return lambda: 25
# # # # #         raise AttributeError('\'Student\' object has no attribution\
# # # # #         \'%s\'' % item)
# # # # #
# # # # #
# # # # # s = Student()
# # # # # # 错误示例，打印自定义报错信息
# # # # # # print(s.ag())
# # # # #
# # # # #
# # # # # # 利用完全动态__getattr__，写出一个链式调用
# # # # # # 因为.的应用，在__getattr__会动态的处理添加的字串
# # # # # # __repr__是面对程序员打印的，__str__是面对用户的
# # # # # class China(object):
# # # # #
# # # # #     def __init__(self, path=''):
# # # # #         self._path = path
# # # # #
# # # # #     def __getattr__(self, path):
# # # # #         return China('%s/%s' % (self._path, path))
# # # # #
# # # # #     def __getattr__(self, path):
# # # # #         if path == 'users':
# # # # #             China('%s/%s' % (self._path, path))
# # # # #             return lambda s: China('%s/%s' % (self._path, s))
# # # # #         return China('%s/%s' % (self._path, path))
# # # # #
# # # # #     def __str__(self):
# # # # #         return self._path
# # # # #
# # # # #     __repr__ = __str__
# # # # #
# # # # #
# # # # # # 链式程序调用
# # # # # print(China().status.user.timeline.list)
# # # # # # 修改参数
# # # # # print(China().status.users('Bob').timeline.list)
# # # # #
# # # # #
# # # # # # __call__直接调用实例本身，只需要定义一个__call__即可
# # # # # class Student(object):
# # # # #
# # # # #     def __init__(self, name):
# # # # #         self.name = name
# # # # #
# # # # #     def __call__(self):
# # # # #         print('My name is %s.' % self.name)
# # # # #
# # # # #
# # # # # s = Student('Bob')
# # # # # s()
# # # # #
# # # # # # 利用callable()函数，判断一个对象是否是"可调用"对象
# # # # # print(callable(Student))
# # # # # print(callable(max))
# # # # # print(callable([1, 2, 3]))
# # # # # print(callable('str'))
# # # # #
# # # # #
# # # #
# # # #
# # # # # from enum import Enum
# # # # #
# # # # # # 枚举类：
# # # # # Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May',
# # # # #                        'Jun', 'Jul', 'Aug', 'Sep', 'Oct',
# # # # #                        'Nov', 'Dec'))
# # # # # # 直接使用Month.Jan来引用一个常量，或者枚举它的所有成员
# # # # # # value属性是自动赋给成员的int常量，默认从1开始计数
# # # # # for name, member in Month.__members__.items():
# # # # #     print(name, '=>', member, ',', member.value)
# # # # #
# # # # #
# # # # # # Enum派生自定义类，来更精准的控制枚举类型
# # # # # from enum import Enum, unique
# # # # #
# # # # #
# # # # # # unique装饰器可以帮助我们检查有没有重复值
# # # # # @unique
# # # # # class Weekday(Enum):
# # # # #     sun = 0  # sun的Value被设定为0
# # # # #     Mon = 1
# # # # #     Tue = 2
# # # # #     Wed = 3
# # # # #     Thu = 4
# # # # #     Fri = 5
# # # # #     Sat = 6
# # # # #
# # # # #
# # # # # # 访问枚举类型
# # # # # day1 = Weekday.Mon
# # # # # print(day1)
# # # # # print(Weekday['Tue'])
# # # # # print(Weekday.Tue.value)
# # # # # print(Weekday.Mon == day1)
# # # # # print(Weekday(1))
# # # # #
# # # # # for name, member in Weekday.__members__.items():
# # # # #     print(name, '=>', member)
# # # # #
# # # # #
# # # # # class Gender(Enum):
# # # # #     Male = 0
# # # # #     Female = 1
# # # # #
# # # # #
# # # # # class Student(object):
# # # # #
# # # # #     def __init__(self, name, gender):
# # # # #         self.name = name
# # # # #         self.gender = gender
# # # # #
# # # # #
# # # # # # 测试:
# # # # # bart = Student('Bart', Gender.Male)
# # # # # if bart.gender == Gender.Male:
# # # # #     print('测试通过!')
# # # # # else:
# # # # #     print('测试失败!')
# # # #
# # # #
# # # # # 使用元类
# # # # # 动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的
# # # # # 而是运行时动态创建的
# # # # # 创建class的方法：使用type()函数
# # # # # 首先定义函数
# # # # # def fn(self, name='world'):
# # # # #     print('Hello, %s' % name)
# # # # #
# # # # #
# # # # # # 动态创建类
# # # # # Hello = type('Hello', (object,), dict(hello=fn))
# # # # # h = Hello()
# # # # # h.hello()
# # # # #
# # # # #
# # # # # # metaclass：先定义metaclass，再创建类，最后创建实例
# # # # # # metaclass类名总是以Metaclass结尾，以便于区分
# # # # # class ListMetaclass(type):
# # # # #
# # # # #     def __new__(cls, name, bases, attrs):
# # # # #         attrs['add'] = lambda self, value: self.append(value)
# # # # #         return type.__new__(cls, name, bases, attrs)
# # # # #
# # # # #
# # # # # # 有了ListMetaclass，我们在定义类的时候还要指示使用ListMetaclass来定制类
# # # # # # 传入关键字参数metaclass：
# # # # # class MyList(list, metaclass=ListMetaclass):
# # # # #     pass
# # # # #
# # # # #
# # # # # L = MyList()
# # # # # L.add(1)
# # # # # print(L)
# # # #
# # # # print('')
# # # #
# # # #
# # # # # 定义一个Field类，负责保存数据库的字段名和字段类型
# # # # class Field(object):
# # # #
# # # #     def __init__(self, name, column_type):
# # # #         self.name = name
# # # #         self.column_type = column_type
# # # #
# # # #     def __str__(self):
# # # #         return '<%s:%s>' % (self.__class__.__name__, self.name)
# # # #
# # # #
# # # # # 在Field的基础上，进一步定义各种类型的Field
# # # # class StringField(Field):
# # # #
# # # #     def __init__(self, name):
# # # #         super(StringField, self).__init__(name, 'varchar(100)')
# # # #
# # # #
# # # # class IntegerField(Field):
# # # #
# # # #     def __init__(self, name):
# # # #         super(IntegerField, self).__init__(name, 'bigiht')
# # # #
# # # #
# # # # # 编写metaclass
# # # # class ModelMetaclass(type):
# # # #
# # # #     def __new__(cls, name, bases, attrs):
# # # #         if name == 'Model':
# # # #             return type.__new__(cls, name, bases, attrs)
# # # #         print('Found model: %s' % name)
# # # #         mappings = dict()
# # # #         for k, v in attrs.items():
# # # #             if isinstance(v, Field):
# # # #                 print('Found mapping: %s ==> %s' % (k, v))
# # # #                 mappings[k] = v
# # # #         for k in mappings.keys():
# # # #             attrs.pop(k)
# # # #         attrs['__mappings__'] = mappings
# # # #         attrs['__table__'] = name
# # # #         return type.__new__(cls, name, bases, attrs)
# # # #
# # # #
# # # # # 基类Model
# # # # class Model(dict, metaclass=ModelMetaclass):
# # # #
# # # #     def __init__(self, **kw):
# # # #         super(Model, self).__init__(**kw)
# # # #
# # # #     def __getattr__(self, key):
# # # #         try:
# # # #             return self[key]
# # # #         except KeyError:
# # # #             raise AttributeError(r"'Model' object has no \
# # # #             attribute '%s'" % key)
# # # #
# # # #     def __setattr__(self, key, value):
# # # #         self[key] = value
# # # #
# # # #     def save(self):
# # # #         fields = []
# # # #         params = []
# # # #         args = []
# # # #         for k, v in self.__mappings__.items():
# # # #             fields.append(v.name)
# # # #             params.append('?')
# # # #             args.append(getattr(self, k, None))
# # # #         sql = 'insert into %s (%s) value (%s)' % (self.__table__,
# # # #                                                   ','.join(fields)
# # # #                                                   .join(params))
# # # #         print('SQL: %s' % sql)
# # # #         print("ARGS: %s" % str(args))
# # # #
# # # #
# # # # u = User(id=12345, name='Michael', email='test@orm.org',
# # # #           password='my-pwd')
# # # # u.save()
# # # #
# # #
# # #
# # # # def foo():
# # # #     # r = some_function()  #此处的some_function还未定义
# # # #     if r == (-1):
# # # #         return (-1)
# # # #     return r
# # # #
# # # #
# # # # def bar():
# # # #     r = foo()
# # # #     if r == (-1):
# # # #         print('Error')
# # # #     else:
# # # #         pass
# # #
# # #
# # # # 以上的代码，用错误码来表示是否出错十分不便，
# # # # 因为函数本身应该返回的正常结果和错误码混在一起，
# # # # 造成调用者必须用大量的代码来判断是否出错：
# # #
# # #
# # # # 所以通常使用try语法来处理错误
# # # # 此处代码10/0有错误，所以result不会被打印，而是直接跳到错误的代码处
# # # # 改为2则正常执行
# # # # try:
# # # #     print('try...')
# # # #     r = 10 / 2
# # # #     print('result:', r)
# # # # except ZeroDivisionError as e:
# # # #     print('except:', e)
# # # # finally:
# # # #     print('finally...')
# # # # print('END')
# # #
# # #
# # # # 使用except来捕获不同类型的错误
# # # # try:
# # # #     print('try...')
# # # #     r = 10 / int('a')
# # # #     print('result:', r)
# # # # except ValueError as e:
# # # #     print('ValueError:', e)
# # # # except ZeroDivisionError as e:
# # # #     print('ZeroDivisionError:', e)
# # # # finally:
# # # #     print('finally...')
# # # # print('END')
# # #
# # #
# # # # Python的错误也是class，所有都继承自BaseException
# # # # 使用except，不但捕获错误，还将子类也全算上
# # # # 下边的程序中，第二个except永远也捕捉不到错误
# # # # 因为UnicodeError是ValueError的子类，假如有就被第一个拦截了，程序终止
# # # # BaseException错误类型和继承关系：
# # # # https://docs.python.org/3/library/exceptions.
# # # # html#exception-hierarchy
# # # # try:
# # # #     foo()
# # # # except ValueError as e:
# # # #     print('ValueError:')
# # # # except UnicodeError as e:
# # # #     print('UnicodeError')
# # #
# # #
# # # # 使用try...except捕获错误可以跨越多层调用
# # # # 在合适的层次中调用就可以捕获别处的错误，不用精确定位
# # # # def foo(s):
# # # #     return 10 / int(s)
# # # #
# # # #
# # # # def bar(s):
# # # #     return foo(s) * 2
# # # #
# # # #
# # # # def main():
# # # #     try:
# # # #         bar('0')
# # # #     except Exception as e:
# # # #         print('Error:', e)
# # # #     finally:
# # # #         print('finally...')
# # #
# # #
# # # # 调用main
# # # # main()
# # #
# # # # 调用栈：异常栈，报错误的日志信息
# # # # 如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获，
# # # # 打印一个错误信息，然后程序退出。来看看err.py：
# # # # def foo(s):
# # # #     return 10 / int(s)
# # # #
# # # #
# # # # def bar(s):
# # # #     return foo(s) * 2
# # # #
# # # #
# # # # def main():
# # # #     bar('0')
# # # #
# # # #
# # # # main()
# # #
# # #
# # # # 记录错误
# # # # 通过配置，logging还可以把错误记录到日志文件里，方便事后排查。
# # # # import logging
# # # #
# # # #
# # # # def foo(s):
# # # #     return 10 / int(s)
# # # #
# # # #
# # # # def bar(s):
# # # #     return foo(s) * 2
# # # #
# # # #
# # # # def main():
# # # #     try:
# # # #         bar('0')
# # # #     except Exception as e:
# # # #         logging.exception(e)
# # # #
# # # #
# # # # main()
# # # # print('END')
# # #
# # #
# # # # 抛出错误
# # # # class FooError(ValueError):
# # # #     pass
# # # #
# # # #
# # # # # 自己定义错误信息
# # # # def foo(s):
# # # #     n = int(s)
# # # #     if n == 0:
# # # #         raise FooError('invalid value: %s' % s)
# # # #     return 10 / n
# # # #
# # # #
# # # # foo('0')
# # #
# # #
# # # # 第二种错误处理
# # # # def foo(s):
# # # #     n = int(s)
# # # #     if n == 0:
# # # #         raise ValueError('2：invalid value: %s' % s)
# # # #     return 10 / n
# # # #
# # # #
# # # # def bar():
# # # #     try:
# # # #         foo('0')
# # # #     except ValueError as e:
# # # #         print('2：ValueError')
# # # #         raise
# # #
# # #
# # # # bar()
# # #
# # #
# # # # raise语句如果不带参数，就会把当前错误原样抛出。
# # # # 此外，在except中raise一个Error，还可以把一种类型的错误转化成另一种类型：
# # # # 只要是合理的转换逻辑就可以，
# # # # 但是，决不应该把一个IOError转换成毫不相干的ValueError。
# # # # try:
# # # #     10 / 0
# # # # except ZeroDivisionError:
# # # #     raise ValueError('input error!')
# # #
# # #
# # # # from functools import reduce
# # # #
# # # #
# # # # def str2num(s):
# # # #     return float(s)
# # # #
# # # #
# # # # def calc(exp):
# # # #     ss = exp.split('+')
# # # #     ns = map(str2num, ss)
# # # #     return reduce(lambda acc, x: acc + x, ns)
# # # #
# # # #
# # # # def main():
# # # #     r = calc('100 + 200 + 345')
# # # #     print('100 + 200 + 345 =', r)
# # # #     r = calc('99 + 88 + 7.6')
# # # #     print('99 + 88 + 7.6 =', r)
# # # #
# # # #
# # # # main()
# # #
# # #
# # # # 调试
# # # # 断言
# # # # def foo(s):
# # # #     n = int(s)
# # # #     assert n != 0, 'n is zero!'
# # # #     return 10 / n
# # # #
# # # #
# # # # def main():
# # # #     foo('0')
# # #
# # #
# # # # main()
# # #
# # #
# # # # 启动Python的-0，可以关闭assert的打印
# # # # 关闭后，你可以把所有的assert语句当成pass来看。
# # #
# # #
# # # # 使用logging来输出错误信息
# # # # logging允许指定记录信息的级别，有debug，info，warning，error等几个级别
# # # # 当我们指定level=INFO时，logging.debug就不起作用了。
# # # # 同理，指定level=WARNING后，debug和info就不起作用了
# # # # 这样一来，可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。
# # # # logging的另一个好处是通过简单的配置，一条语句可以同时输出到不同的地方，
# # # # 比如console和文件。
# # # # import logging
# # # # logging.basicConfig(level=logging.INFO)
# # # #
# # # # s = '0'
# # # # n = int(s)
# # # # logging.info('n = %d' % n)
# # # # print(10 / n)
# # #
# # #
# # # # 第四种，需要Python的调试器pdb
# # #
# # #
# # # # 单元测试：用来测试函数是否能够正常使用
# # # # 编写一个Dict类，这个类的行为和dict一致，但是可以通过属性来访问
# # # # class Dict(dict):
# # # #
# # # #     def __init__(self, **kw):
# # # #         super().__init__(**kw)
# # # #
# # # #     def __getattr__(self, key):
# # # #         try:
# # # #             return self[key]
# # # #         except KeyError:
# # # #             raise AttributeError(r"'Dict object has no attribute '%s'"
# # # #                                  % key)
# # # #
# # # #     def __setattr__(self, key, value):
# # # #         self[key] = value
# # # #
# # # #
# # # # d = Dict(a=1, b=2)
# # # # print(d['a'])
# # # # print(d.a)
# # #
# # #
# # # # 编写单元测试，我们需要引入Python自带的unittest模块，编写mydict_test.py如下
# # # import unittest
# # #
# # # from mydict import Dict
# # #
# # #
# # # # setUp和tearDown
# # # # setUp()和tearDown()方法。这两个方法会分别在每调用一个测试方法的前后分别被执行
# # # # 可以再次运行测试看看每个测试方法调用前后是否会打印出setUp...和tearDown...
# # # # class TestDict(unittest.TestCase):
# # # #
# # # #     def setUp(self):
# # # #         print('setUp...')
# # # #
# # # #     def test_init(self):
# # # #         d = Dict(a=1, b='test')
# # # #         self.assertEqual(d.a, 1)
# # # #         self.assertEqual(d.b, 'test')
# # # #         self.assertTrue(isinstance(d, dict))
# # # #         print('1...')
# # # #
# # # #     def test_key(self):
# # # #         d = Dict()
# # # #         d['key'] = 'value'
# # # #         self.assertEqual(d.key, 'value')
# # # #         print('2...')
# # # #
# # # #     def test_attr(self):
# # # #         d = Dict()
# # # #         d.key = 'value'
# # # #         self.assertTrue('key' in d)
# # # #         self.assertEqual(d['key'], 'value')
# # # #         print('3...')
# # # #
# # # #     def test_keyerror(self):
# # # #         d = Dict()
# # # #         with self.assertRaises(KeyError):
# # # #             value = d['empty']
# # # #         print('4...')
# # # #
# # # #     def test_attreror(self):
# # # #         d = Dict()
# # # #         with self.assertRaises(AttributeError):
# # # #             value = d.empty
# # # #         print('5...')
# # # #
# # # #     def tearDown(self):
# # # #         print('tearDown...')
# # # #
# # # #
# # # # if __name__ == '__main__':
# # # #     unittest.main()
# # #
# # #
# # # class Student(object):
# # #     def __init__(self, name, score):
# # #         self.name = name
# # #         self.score = score
# # #
# # #     def get_grade(self):
# # #         if 80 <= self.score <= 100:
# # #             return 'A'
# # #         elif 60 <= self.score < 80:
# # #             return 'B'
# # #         elif self.score < 0 or self.score > 100:
# # #             raise ValueError
# # #         return 'C'
# # #
# # #
# # # class TestStudent(unittest.TestCase):
# # #
# # #     def test_80_to_100(self):
# # #         s1 = Student('Bart', 80)
# # #         s2 = Student('Lisa', 100)
# # #         self.assertEqual(s1.get_grade(), 'A')
# # #         self.assertEqual(s2.get_grade(), 'A')
# # #
# # #     def test_60_to_80(self):
# # #         s1 = Student('Bart', 60)
# # #         s2 = Student('Lisa', 79)
# # #         self.assertEqual(s1.get_grade(), 'B')
# # #         self.assertEqual(s2.get_grade(), 'B')
# # #
# # #     def test_0_to_60(self):
# # #         s1 = Student('Bart', 0)
# # #         s2 = Student('Lisa', 59)
# # #         self.assertEqual(s1.get_grade(), 'C')
# # #         self.assertEqual(s2.get_grade(), 'C')
# # #
# # #     def test_invalid(self):
# # #         s1 = Student('Bart', -1)
# # #         s2 = Student('Lisa', 101)
# # #         with self.assertRaises(ValueError):
# # #             s1.get_grade()
# # #         with self.assertRaises(ValueError):
# # #             s2.get_grade()
# # #
# # #
# # # if __name__ == '__main__':
# # #     unittest.main()
# #
# # # 文档测试
# # import re
# #
# # m = re.search('(?<=abc)def', 'abcdef')
# # print(m.group(0))
# #
# #
# # def abs(n):
# #     """
# #     Function to get absolute value of number.
# #
# #     Example:
# #
# #     >>> abs(1)
# #     1
# #     >>> abs(-1)
# #     1
# #     >>> abs(0)
# #     0
# #     """
# #
# #     return n if n >= 0 else (-n)
#
#
# # 文件读写
# # 读文件:
# # 1.打开文件
# f = open('/Users/yangxudong/Desktop/HelloPython/mydict.py', 'r')
# # 2.read()读文件:调用read()方法可以一次读取文件的全部内容，Python把内容读到内存，
# # 用一个str对象表示
# # print(f.read())
# # 3.关闭文件夹：避免占用系统资源，因为同一时间打开的文件夹是有数量限制的
# f.close()
#
# # 使用with语句来正确调用close()方法，保证能关闭文件
# # with open('/Users/yangxudong/Desktop/HelloPython/mydict.py', 'r') as f:
# #     print(f.readlines())
# #     把末尾的'\n'删掉
# #     for line in f.readlines():
# #         print(line.strip())
#
# # read(size)限制每次读取的大小，readline():每次读取一行内容
# # readlines()：读取所有内容，并将所有内容按list返回
#
# # file-like Object:像open()函数返回的这种有个read()方法的对象，
# # 在Python中统称为file-like Object
# # 除了file外，还可以是内存的字节流，网络流，自定义流等等。
# # file-like Object不要求从特定类继承，只要写个read()方法就行。
#
# # 二进制文件
# # 前面讲的默认都是读取文本文件，并且是UTF-8编码的文本文件。
# # 要读取二进制文件，比如图片、视频等等，用'rb'模式打开文件即可：
# f = open('/Users/yangxudong/Desktop/HelloPython/111.png', 'rb')
# # print(f.read())
#
# # 字符编码
# # 要读取非UTF-8编码的文本文件，需要给open()函数传入encoding参数，例，读取GBK编码的文件
# # f = open('/Users/yangxudong/Desktop/gbk.text', 'r', encoding='gbk')
# # print(f.read())
# # 遇到有些编码不规范的文件，你可能会遇到UnicodeDecodeError，
# # 因为在文本文件中可能夹杂了一些非法编码的字符。
# # 遇到这种情况，open()函数还接收一个errors参数，表示如果遇到编码错误后如何处理。
# # 最简单的方式是直接忽略：
# # f = open('e', 'r', encoding='gbk', errors='ignore')
#
# # 写文件
# # 写文件首先也要打开文件，在写文件时，传入标识符，'w'或者'wb'表示写文本文件或者二进制文件
# # f = open('/Users/yangxudong/Desktop/HelloPython/mydict.py', 'w')
# # f.write('Hello, world')
# # f.close()
# # 此方法会自动，在写完之后，会自动调用close()方法
# # 以'w'模式写入文件时，如果文件已存在，会直接覆盖（相当于删掉后新写入一个文件）。
# # 如果我们希望追加到文件末尾怎么办？可以传入'a'以追加（append）模式写入。
# with open('/Users/yangxudong/Desktop/HelloPython/mydict.py', 'a') as f:
#     f.write('Hello, world! \n')
#
# # StringIO和BytesIO
# # StringIO：在内存中读写str
# # 要把str写入StringIO，我们需要先创建一个StringIO，然后，像文件一样写入即可
# from io import StringIO
#
# f = StringIO()
# print(f.write('hello'))
# print(f.write(' '))
# print(f.write('world'))
# # getvalue()方法用于获得写入后的str。
# print(f.getvalue())
#
# # 要读取StringIO，可以用一个str初始化StringIO，然后，像读文件一样读取：
# from io import StringIO
#
# f = StringIO('Hello!\nHi\nGoodBye')
# while True:
#     s = f.readline()
#     if s == '':
#         break
#     print(s.strip())
#
# # BytesIO:操作二进制数据，使用BytesIO
# # 我们创建一个BytesIO，然后写入一些bytes
# from io import BytesIO
#
# f = BytesIO()
# f.write('中文'.encode('utf-8'))
# print(f.getvalue())
#
# # 和StringIO类似，可以用一个bytes初始化BytesIO，然后，像读文件一样读取：
# from io import BytesIO
#
# f = BytesIO(b'\xe4\xb8\xad\xe6\x96\x87')
# print(f.read())
#
# # 操作文件和目录
# # Python内置的os模块也可以直接调用操作系统提供的接口函数
# import os
#
# print(os.name)
# # 获取详细的系统信息，可以调用uname()函数：
# print(os.uname())
#
# # 环境变量
# # 在操作系统中定义的环境变量，全部保存在os.environ这个变量中，可以直接查看
# print(os.environ)
# # 获取某个环境变量的值
# print(os.environ.get("PATH"))
# print(os.environ.get('x', 'default'))
#
# # 操作文件和目录
# # 查看当前目录的绝对路径
# print(os.path.abspath('.'))
# # 在某个目录下创建一个新的项目，首先把新目录的完整路径表示出来
# print(os.path.join('/Users/yangxudong/Desktop', 'testdir'))
# # 然后创建一个目录
# # os.mkdir('/Users/yangxudong/Desktop/testdir')
# # 删掉一个目录
# # os.rmdir('/Users/yangxudong/Desktop/testdir')
# # 把两个路径合成一个
# # 不要直接拼字符串，而要通过os.path.join()函数，这样可以正确处理不同操作系统的路径分隔符
# # 在Linux/Unix/Mac下，os.path.join()返回这样的字符串
# # part-1/part-2
#
# # 而Windows下会返回这样的字符串：
# # part-1\part-2
#
# # 同样的道理，要拆分路径时，也不要直接去拆字符串，
# # 而要通过os.path.split()函数，这样可以把一个路径拆分为两部分，
# # 后一部分总是最后级别的目录或文件名：
# print(os.path.split('/Users/yangxudong/Desktop/testdir'))
# # 获得文件的扩展名
# # 这些合并、拆分路径的函数并不要求目录和文件要真实存在，它们只对字符串进行操作
# print(os.path.splitext('/Users/yangxudong/Desktop/testdir/house.png'))
# # 对文件重命名
# # 重命名之后，如果不加路径。文件就会更改位置，所以需要加上更改后的路径
# # os.rename('/Users/yangxudong/Desktop/testdir/222.png',
# #           '/Users/yangxudong/Desktop/testdir/111.png')
# # os中不存在复制模块
# # 幸运的是shutil模块提供了copyfile()的函数
# # 你还可以在shutil模块中找到很多实用函数，它们可以看做是os模块的补充
# print([x for x in os.listdir('.') if os.path.isdir(x)])
# # 列出所有的.py文件
# print(x for x in os.listdir('.') if os.path.isfile(x) and
#       os.path.splitext(x)[1] == '.py')
#
# # import os
# # import os.path as op
# #
# # inp = input('请输入字符串，我将为你查找是否有包含字符串的文件:')
# #
# #
# # def get_files(inp, n_dir='.'):
# #     x = os.listdir(n_dir)
# #     if x == False:
# #         pass
# #     for fi in x:
# #         if op.isdir(fi):
# #             get_files(inp, fi)
# #         else:
# #             file = op.split(fi)
# #             if inp in file[1]:
# #                 print(file[1])
# #
# #
# # get_files(inp)
#
#
# # import os
# #
# # s = input('Input the string you want find:')
# # ls = []
# # for x in os.listdir('.'):
# #     if s in x:
# #         ls.append(x)
# #         print(x, "\n")
# #     if os.path.isdir(x):
# #         for y in os.listdir('./' + x):
# #             if s in y:
# #                 ls.append('./' + y)
# #                 print('./' + y + "\n")
# # print(ls)
#
# # 序列化
# # 在程序运行过程中，所有的变量都是在内存中，比如，定义一个dict
# # 可以随时修改变量，比如把name改成'Bill'，
# # 但是一旦程序结束，变量所占用的内存就被操作系统全部回收。
# # 如果没有把修改后的'Bill'存储到磁盘上，下次重新运行程序，变量又被初始化为'Bob'
# # d = dict(name='Bob', age=20, socre=88)
#
# # 我们把变量从内存中变成可存储或传输的过程称之为序列化，
# # 在Python中叫pickling，
# # 在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思
# # 序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。
# # 反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling
# # Python提供了pickle模块来实现序列化
# import pickle
#
# # 把一个对象序列化并写入文件
# d = dict(name='Bob', age=20, score=88)
# print(pickle.dumps(d))
#
# # pickle.dumps()方法把任意对象序列化成一个bytes，
# # 然后，就可以把这个bytes写入文件。
# # 或者用另一个方法pickle.dump()直接把对象序列化后写入一个file-like Object
# # f = open('dump.text', 'wb')
# # pickle.dump(d, f)
# # f.close()
# # print(d)
#
# # Python转变为json数据
# import json
#
# d = dict(name='Bob', age=20, score=88)
# # print(json.dumps(d))
#
# # dumps()方法返回一个str，内容就是标准的json
# # 类似的，dump()方法可以直接把JSON写入一个file-like Object
#
# # 要把JSON反序列化为Python对象，用loads()或者对应的load()方法，
# # 前者把JSON的字符串反序列化，后者从file-like Object中读取字符串并反序列化
# # 由于JSON标准规定JSON编码是UTF-8，
# # 所以我们总是能正确地在Python的str与JSON的字符串之间转换。
# json_str = '{"age": 20, "score": 88, "name": "Bob"}'
# # print(json.loads(json_str))
#
# # Python的dict对象可以直接序列化为JSON的{}，
# # 不过，很多时候，我们更喜欢用class表示对象，比如定义Student类，然后序列化：
# import json
#
#
# class Student(object):
#
#     def __init__(self, name, age, score):
#         self.name = name
#         self.age = age
#         self.score = score
#
#
# # 此处无法直接将class转化为json
# s = Student('Bob', 20, 88)
#
#
# # print(json.dumps(s))
#
# # 可选参数default就是把任意一个对象变成一个可序列为JSON的对象，
# # 我们只需要为Student专门写一个转换函数，再把函数传进去即可
# def student2dict(std):
#     return {
#         'name': std.name,
#         'age': std.age,
#         'score': std.score
#     }
#
#
# # Student实例首先被student2dict()函数转换成dict，然后再被顺利序列化为JSON
# print(json.dumps(s, default=student2dict))
# # 不过，下次如果遇到一个Teacher类的实例，照样无法序列化为JSON。
# # 我们可以偷个懒，把任意class的实例变为dict：
# # 通常class的实例都有一个__dict__属性，实际上就是一个dict，用来存储少量数据
# # 也有少数列外，例如定义了__slots__属性的class
# print(json.dumps(s, default=lambda obj: obj.__dict__))
#
#
# # 同样的道理，如果我们要把JSON反序列化为一个Student对象实例，
# # loads()方法首先转换出一个dict对象，
# # 然后，我们传入的object_hook函数负责把dict转换为Student实例
# def dict2student(d):
#     return Student(d['name'], d['age'], d['score'])
#
#
# json_str = '{"age": 20, "score": 88, "name": "Bob"}'
# # 打印出的是反序列化的Student实例对象
# print(json.loads(json_str, object_hook=dict2student))
#
#
# obj = dict(name='小明', age=20)
# s = json.dumps(obj, ensure_ascii=True)
# print(s)

# import os

# print('Process (%s) start...' % os.getpid())

# 多进程：getppid()得到父进程的id, 子进程永远返回0. fork()用来开辟子进程

# pid = os.fork()
#
# if pid == 0:
#     print('I am child process (%s) and my parent is %s.' % (os.getpid(),
#                                                             os.getppid()))
# else:
#     print('I (%s) just create a child process (%s).' % (os.getpid(), pid))
#
#
# # multiprocessing：跨平台版本的多进程模块
# from multiprocessing import Process
# import os
#
#
# # 子进程执行的代码
# def run_proc(name):
#     print('Run child process %s (%s)...' % (name, os.getpid()))
#
#
# if __name__ == '__main__':
#     print('Parent process %s.' % os.getpid())
#     p = Process(target=run_proc, args=('test',))
#     print('Child process will start.')
#     p.start()
#     p.join()
#     print('Child process end.')


# Pool：进程池，批量创建子进程
# from multiprocessing import Pool
# import os, time, random
#
#
# def long_time_task(name):
#     print('Run task %s (%s)...' % (name, os.getpid()))
#     start = time.time()
#     time.sleep(random.random() * 3)
#     end = time.time()
#     print('Task %s runs %0.2f seconds.' % (name, (end - start)))
#
#
# if __name__ == '__main__':
#     print('Parent process %s.' % os.getpid())
#     p = Pool(4)
#     for i in range(5):
#         p.apply_async(long_time_task, args=(i,))
#     print('Waiting for all subprocesses done...')
#     p.close()
#     p.join()
#     print('All subprocesses done.')

# 子进程：很多时候并不是自身，而是一个外部进程。创建了子进程后，还要控制输入和输出
# subprocess：这个模块可以让我们非常方便的启动一个子进程，然后控制输入和输出
# 下面的例子演示了如何在Python代码中运行命令nslookup www.python.org，
# 这和命令行直接运行的效果是一样的：
# import subprocess
#
# print('$ nslookup www.python.org')
# r = subprocess.call(['nslookup', 'www.python.org'])
# print('Exit code:', r)

# 如果子进程还需要输入，则可以通过communicate()方法输入：
# import subprocess
#
# print('$ nslookup')
# p = subprocess.Popen(['nslookup'], stdin=subprocess.PIPE,
#                      stdout=subprocess.PIPE, stderr=subprocess.PIPE)
# output, err = p.communicate(b'set q=mx\npython.org\nexit\n')
# print(output.decode('utf-8'))
# print('Exit code:', p.returncode)

# 上边的代码相当于在命令行执行命令nslookup，然后手动输入
# set q=mx
# python.org
# exit

# 进程间的通信
# Process之间肯定是需要通信的，操作系统提供了很多机制来实现进程间的通信。
# Python的multiprocessing模块包装了底层的机制，提供了Queue、Pipes等多种方式来交换数据。
# from multiprocessing import Process, Queue
# import os, time, random
#
#
# # 写数据进程执行的代码
# # getpid返回当前进程标识，getppid返回父进程标识。
# def write(q):
#     print('Process to write: %s' % os.getpid())
#     for value in ['A', 'B', 'C']:
#         print('Put %s to queue...' % value)
#         q.put(value)
#         time.sleep(random.random())
#
#
# # 读取数据进程执行的代码
# def read(q):
#     print('Process to read: %s' % os.getpid())
#     while True:
#         value = q.get(True)
#         print('Get %s from queue.' % value)
#
#
# if __name__ == '__main__':
#     # 父进程创建Queue，并传给各个子进程
#     q = Queue()
#     pw = Process(target=write, args=(q,))
#     pr = Process(target=read, args=(q,))
#     # 启动子进程pw，写入：
#     pw.start()
#     # 启动子进程，读取：
#     pr.start()
#     # 等待pw结束
#     pw.join()
#     # pr进程里是死循环，无法等待其结束，只能强行终止
#     pr.terminate()
# 多任务可以由多进程完成，也可以由一个进程内的多线程完成
# Python的标准库提供了两个模块：_thread和threading，
# _thread是低级模块，threading是高级模块，对_thread进行了封装。
# 绝大多数情况下，我们只需要使用threading这个高级模块

# 启动一个线程就是把一个函数传入并创建Thread实例，然后调用start()开始执行
# 由于任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程，
# Python的threading模块有个current_thread()函数，它永远返回当前线程的实例。
# 主线程实例的名字叫MainThread，子线程的名字在创建时指定，我们用LoopThread命名子线程。
# 名字仅仅在打印时用来显示，完全没有其他意义，
# 如果不起名字Python就自动给线程命名为Thread-1，Thread-2……
# import time, threading
#
#
# def loop():
#     print('thread %s is running...' % threading.current_thread().name)
#     n = 0
#     while n < 5:
#         n = n + 1
#         print('thread %s >>> %s' % (threading.current_thread().name, n))
#         time.sleep(1)
#     print('thread %s ended.' % threading.current_thread().name)
#
#
# print('thread %s is running...' % threading.current_thread().name)
# t = threading.Thread(target=loop, name='LoopThread')
# t.start()
# t.join()
# print('thread %s ended.' % threading.current_thread().name)

# 多线程之间最大的问题在于，多个线程同时操作一个变量，造成内容混乱
# 当t1、t2交替执行时，只要循环次数足够多，balance的结果就不一定是0了
# import time, threading

# balance = 0


# def change_it(n):
#     # 先存后取，结果应该为0
#     global balance
#     balance = balance + n
#     balance = balance - n
#
#
# def run_thread(n):
#     for i in range(100000):
#         change_it(n)
#
#
# t1 = threading.Thread(target=run_thread, args=(5,))
# t2 = threading.Thread(target=run_thread, args=(5,))
# t1.start()
# t2.start()
# t1.join()
# t2.join()
# print('no lock %s' % balance)


# 在一个线程修改balance时，别的线程不能对balance修改
# 对线程进行加锁：同一时刻最多只有一个线程持有锁

# balance = 0
# lock = threading.Lock()
#
#
# def run_thread(n):
#     for i in range(100000):
#         # 先要获取锁
#         lock.acquire()
#         try:
#             # 修改
#             change_it(n)
#         finally:
#             # 修改完成之后，释放锁🔐
#             lock.release()


# 当多个线程同时执行lock.acquire()时，只有一个线程能成功的获取锁
# 然后继续执行代码，其他线程持续等待，直到获取锁为止
# 我们用try...finally来确保锁一定会被释放


# ThreadLocal
# 在多线程环境下，每个线程都有自己的数据。
# 一个线程使用自己的局部变量比使用全局变量好，
# 因为局部变量只有线程自己能看见，不会影响其他线程，而全局变量的修改必须加锁。
# 使用局部变量的问题，在函数调用的时候，传递起来很麻烦

# class Student(object):
#
#     def __init__(self, name, score):
#         self.name = name
#         self.score = score
#
#     pass


# def process_student(name):
#     # std是局部变量，但是每个函数都要用它，因此必须传进去：
#     std = Student(name)
#     do_task_1(std)
#     do_task_2(std)
#
#
# def do_task_1(std):
#     do_subtask_1(std)
#     do_subtsak_2(std)
#
#
# def do_task_2(std):
#     do_subtask_2(std)
#     do_subtask_2(std)

# 创建全局Threading对象
# ThreadLocal最常用的地方就是为每个线程绑定一个数据库连接，
# HTTP请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。
# import threading
#
# local_school = threading.local()
#
#
# def process_student():
#     # 获取当前线程关联的student
#     std = local_school.student
#     print('Hello, %s (in %s)' % (std, threading.current_thread().name))
#
#
# def process_thread(name):
#     # 绑定ThreadLocal的student
#     local_school.student = name
#     process_student()
#
#
# t1 = threading.Thread(target=process_thread, args=('Alice',),
#                       name='Thread-A')
# t2 = threading.Thread(target=process_thread, args=('Bob',),
#                       name='Thread-B')
# t1.start()
# t2.start()
# t1.join()
# t2.join()

# 一个ThreadLocal变量虽然是全局变量，但每个线程都只能读写自己线程的独立副本，互不干扰。
# ThreadLocal解决了参数在一个线程中各个函数之间互相传递的问题

# 对于计算密集型任务，最好用C语言编写

# 如果充分利用操作系统提供的异步IO支持，就可以用单进程单线程模型来执行多任务，
# 这种全新的模型称为事件驱动模型

# 对应到Python语言，单线程的异步编程模型称为协程，
# 有了协程的支持，就可以基于事件驱动编写高效的多任务程序。我们会在后面讨论如何编写协程。

# 分布式进程
# 在Thread和Process中，应当优选Process，因为Process更稳定，
# 而且，Process可以分布到多台机器上，而Thread最多只能分布到同一台机器的多个CPU上

# 如果我们已经有一个通过Queue通信的多进程程序在同一台机器上运行，
# 现在，由于处理任务的进程任务繁重，希望把发送任务的进程和处理任务的进程分布到两台机器上。
# 怎么用分布式进程实现？

# 原有的Queue可以继续使用，但是，通过managers模块把Queue通过网络暴露出去，
# 就可以让其他机器的进程访问Queue了。


# 判断一个字符串是否是一个合法的Email





























